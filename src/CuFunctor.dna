copyrightText = 
""" *
 *"""
#  CuFunctor.dna - template used by ribosome to generate functor methods 
#  glue code to enable pass-by-value polymorphism
#

class String
  def uncapitalize 
    self[0, 1].downcase + self[1..-1]
  end
end

# static base members ( set by invoking make with 'statFunc=1' )
statFunc = ( ENV['cufuncStatic'] == 'true' )
# kernel templates (by functor)
kts = ( ENV['cuKts'] == 'true' )
 puts "kts ", kts
 puts "statFunc ", statFunc
 
runTime = Time.new()
# filenames
fUnaryOp = "src/UnaryOpF_Gen.h"
fUnaryOpIdx = "src/UnaryOpIndexF_Gen.h"
fBinaryOp = "src/BinaryOpF_Gen.h"
fEnum = "src/FunctorEnums_Gen.h"
if(!kts)
    fBaseUnaryOp = "src/BaseUnaryOpF_Gen.h"
    fBaseIop = "src/BaseUnaryOpIndexF_Gen.h"
    fBaseBop = "src/BaseBinaryOpF_Gen.h"
    if(statFunc) 
        fMethodTableMgr = "src/FunctionTableMgr_Gen.cu"
    else
        fMethodTableMgr = "src/MethodTableMgr_Gen.cu"
    end # statFunc
end
puts "fMethodTableMgr ", fMethodTableMgr
# switch to add debug output identifying which function is called:  base class's operator<<Name>> or subclass's <<Name>>::operator()(..)  
locateFunction = ( ENV['cufuncLocate'] == 'true' )


if(!kts)
    # create enum file (for binder kernels)
    ./!output(fEnum)
    ./*
    .&{copyrightText}
    . *  
    . *  FunctorEnums_Gen.h
    . *  indices into the host-side copies of device side functor methods 
    . *  Generated by ribosome at @{runTime}
    . *
    . */
    .#pragma once
    .
    
    # create  MethodTableMgr.cu
    ./!output(fMethodTableMgr)
    ./*
    .&{copyrightText}
    . *  
    if(statFunc) 
    . *  FunctionTableMgr_Gen.cu
    else
    . *  MethodTableMgr_Gen.cu
    end #statFuc
    
    . *  binds __device__ operator()s to host-side method tables
    . *  Generated by ribosome at @{runTime}
    . *
    . */
    .#include <typeinfo>
    .#include "FunctorEnums_Gen.h"
    .#include "UnaryOpF_Gen.h"
    .#include "UnaryOpIndexF_Gen.h"
    .#include "BinaryOpF_Gen.h"
    .
    .
    if(statFunc) 
        .template <typename T> FunctionTableMgr<T>::iop0sFunction FunctionTableMgr<T>::h_iop0sFunctions[MAX_GPUS][Iop0sLast];
        .template <typename T> FunctionTableMgr<T>::iop1sFunction FunctionTableMgr<T>::h_iop1sFunctions[MAX_GPUS][Iop1sLast];
        .template <typename T> FunctionTableMgr<T>::iop2sFunction FunctionTableMgr<T>::h_iop2sFunctions[MAX_GPUS][Iop2sLast];
        .template <typename T> FunctionTableMgr<T>::iop3sFunction FunctionTableMgr<T>::h_iop3sFunctions[MAX_GPUS][Iop3sLast];
        .template <typename T> FunctionTableMgr<T>::uop0sFunction FunctionTableMgr<T>::h_uop0sFunctions[MAX_GPUS][Uop0sLast];
        .template <typename T> FunctionTableMgr<T>::uop1sFunction FunctionTableMgr<T>::h_uop1sFunctions[MAX_GPUS][Uop1sLast];
        .template <typename T> FunctionTableMgr<T>::uop2sFunction FunctionTableMgr<T>::h_uop2sFunctions[MAX_GPUS][Uop2sLast];
        .template <typename T> FunctionTableMgr<T>::bop0sFunction FunctionTableMgr<T>::h_bop0sFunctions[MAX_GPUS][Bop0sLast];
        .template <typename T> FunctionTableMgr<T>::bop1sFunction FunctionTableMgr<T>::h_bop1sFunctions[MAX_GPUS][Bop1sLast];
        .
        .template struct FunctionTableMgr<float>;
        .template struct FunctionTableMgr<double>;
        .template struct FunctionTableMgr<long>;
        .template struct FunctionTableMgr<ulong>;
        .template struct FunctionTableMgr<uint>;
        .template struct FunctionTableMgr<int>;
    else
        .template <typename T> MethodTableMgr<T>::iop0sMethod MethodTableMgr<T>::h_iop0sMethods[MAX_GPUS][Iop0sLast];
        .template <typename T> MethodTableMgr<T>::iop1sMethod MethodTableMgr<T>::h_iop1sMethods[MAX_GPUS][Iop1sLast];
        .template <typename T> MethodTableMgr<T>::iop2sMethod MethodTableMgr<T>::h_iop2sMethods[MAX_GPUS][Iop2sLast];
        .template <typename T> MethodTableMgr<T>::iop3sMethod MethodTableMgr<T>::h_iop3sMethods[MAX_GPUS][Iop3sLast];
        .template <typename T> MethodTableMgr<T>::uop0sMethod MethodTableMgr<T>::h_uop0sMethods[MAX_GPUS][Uop0sLast];
        .template <typename T> MethodTableMgr<T>::uop1sMethod MethodTableMgr<T>::h_uop1sMethods[MAX_GPUS][Uop1sLast];
        .template <typename T> MethodTableMgr<T>::uop2sMethod MethodTableMgr<T>::h_uop2sMethods[MAX_GPUS][Uop2sLast];
        .template <typename T> MethodTableMgr<T>::bop0sMethod MethodTableMgr<T>::h_bop0sMethods[MAX_GPUS][Bop0sLast];
        .template <typename T> MethodTableMgr<T>::bop1sMethod MethodTableMgr<T>::h_bop1sMethods[MAX_GPUS][Bop1sLast];
        .
        .template struct MethodTableMgr<float>;
        .template struct MethodTableMgr<double>;
        .template struct MethodTableMgr<long>;
        .template struct MethodTableMgr<ulong>;
        .template struct MethodTableMgr<uint>;
        .template struct MethodTableMgr<int>;
    end #statFunc
    ./*
    . * Store the device-side addresses of stateless unary op functors
    . */
    if(statFunc) 
        .template <typename T> __global__ void findUop0sFunctions( 
        .    typename UnaryOpF<T,0>::uopFunction *uopFunctions) {
        .       if(checkDebug(debugFtor))printf("findUop0sFunctions uopFunctions %p\n", uopFunctions);
    else
        .template <typename T> __global__ void findUop0sMethods( 
        .    typename UnaryOpF<T,0>::uopMethod *uopMethods) {
        .       if(checkDebug(debugFtor))printf("findUop0sMethods uopMethods %p\n", uopMethods);
    end #statFunc

    ./!output(fBaseUnaryOp)
    ./*
    .&{copyrightText}
    . *
    . *  BaseUnaryOpF_Gen.h
    . *  base functor that operates on a single input (of same datatype as state and output)
    . *  Generated by ribosome at @{runTime}
    . *
    . */
    .#pragma once
    .#include "CuFunctor.h"
    .
else
    # create empty enum file (for binder kernels)
    ./!output(fEnum)
    ./*
    .&{copyrightText}
    . *  
    . *  FunctorEnums_Gen.h
    . *  indices into the host-side copies of device side functor methods 
    . *  Generated by ribosome at @{runTime}
    . *
    . */
    .#pragma once
    .
    ./*
    . * intentionally left empty for kernel templates build
    . */    
end #kts


./!output(fUnaryOp)
./*
.&{copyrightText}
. *
. *  UnaryOpF_Gen.h
. *  functors that operate on a single input (of same datatype as state and output)
. *  Generated by ribosome at @{runTime}
. *
. */
.#pragma once
.
.#include "CuFunctor.h"

if(!kts)
    .#include "BaseUnaryOpF_Gen.h"
    ./!append(fBaseUnaryOp)
else
    ./!append(fUnaryOp)
end

.template<typename T, int StateDim> struct UnaryOpF: public CuFunctor<T, StateDim> {
.
if(!kts)
    if(statFunc) 
        uopMethodDec=["    typedef T (*uopFunction)(const UnaryOpF<T,", 
        """>&,T);
    uopFunction fn;
        
    __host__ __device__ T operator()(T xi) const {
        return  (*this->fn)(*this,xi);
    }"""]
    else
        uopMethodDec=
         ["    typedef T (UnaryOpF<T," ,
         """>::*uopMethod)(T)const;
    uopMethod operation;
        
    __host__ __device__ T operator()(T xi) const {
        return  (this->*operation)(xi);
    }"""]
    end #statFunc
    uopm = uopMethodDec[0] + "StateDim" + uopMethodDec[1]
.    // the typedef and member decl of the member function pointer used to insure that
.    // a subfunctor instance passed via a base functor still executes its operator
    .&{uopm}
.
.    __host__ __device__ void init(int currDev) {
    if(statFunc) 
    .        fn = 0;
    else
    .        operation = 0;
    end #statFunc
    .    }
else
    .    __host__ __device__ T operator()(T xi) const { return 7; }
    .    __host__ __device__ void init(int currDev) {}
end    
.}; // UnaryOpF
.
./!append(fUnaryOp)
.
./*
. *    stateless unary ops
. */
.
nameExps = [
    ["Sigmoid", 
        "return static_cast<T>(1.) / (static_cast<T>(1.) + static_cast<T>(expf(-xi)));"],
    ["SigmoidGradient", 
        """T t = (static_cast<T>(1.) / (static_cast<T>(1) + static_cast<T>(expf(-xi))));
    return t * (1. - t);"""],
    ["Deg2", "return - xi* xi - 2 * xi + 11.5;"],
   
    ["Negate", "return (static_cast<T>(-xi));" ],
    ["Log", "return (static_cast<T>(logf(xi)));"],
    ["Floor", "return (static_cast<T>(floor(xi)));"],
    ["Ceil", "return (static_cast<T>(ceilf(xi)));"],
    ["Abs", "return (static_cast<T>(fabs(xi)));"],
    ["OneOver", "return (static_cast<T>(1.) / static_cast<T>(xi));"],
    ["Exp","return (static_cast<T>(expf(xi)));"],
    ["poly2_1","return xi * xi - 2 * xi - 11.5;"],
    ["Sqrt", "return (static_cast<T>(sqrt(xi)));"],
    ["ApproxInvSqrt", "return static_cast<T>(1) / sqrtf(xi);"],
     ["Sqr", "return (xi * xi);"],
    ["SlowInvSqrt", "return static_cast<T>(1) / sqrtf(xi);"],
    ["OneOrZero", "return (xi == 0 || xi == 1);"]
        ]
# setupXsMethodTables will copy the device-side member function pointer to host-side arrays 
if(statFunc) 
    setup0sFunctionTables = ""
else
    setup0sMethodTables = ""
end # statFunc

allUnaryOpDecs=""
allUnaryOpImpls=""
allUnaryOpAccs=""

# create 0 template
if(!kts)
    . /!append(fBaseUnaryOp)
    .template<typename T> struct UnaryOpF<T,0>: public CuFunctor<T, 0> {
    .
    uopm = uopMethodDec[0] + "0" + uopMethodDec[1]
    .&{uopm}
    .
    # create enum
    . /!append(fEnum)
    .enum UnaryOp0sMethods {
end #kts

nameExps.each do |nameExp|
    name = nameExp[0]
    uncap = name.uncapitalize
    exp = nameExp[1]
    
    if(!kts)
        # write enum
        . /!append(fEnum)
        .    Uop0s@{name}UnaryOp,
        
        # write finder
        . /!append(fMethodTableMgr)
        if(statFunc)
        .    uopFunctions[Uop0s@{name}UnaryOp] = &UnaryOpF<T,0>::operator@{name};
        else
        .    uopMethods[Uop0s@{name}UnaryOp] = &UnaryOpF<T,0>::operator@{name};
        end #statFunc
        
        # add method copy
        if(statFunc)
            setup0sFunctionTables += "    checkCudaErrors(cudaMemcpy(&FunctionTableMgr<T>::h_uop0sFunctions[device][Uop0s" + name + "UnaryOp], &uopFunctions[Uop0s" + name + "UnaryOp], sizeof(typename UnaryOpF<T,0>::uopFunction),cudaMemcpyDeviceToHost));\n"
        else
            setup0sMethodTables += "    checkCudaErrors(cudaMemcpy(&MethodTableMgr<T>::h_uop0sMethods[device][Uop0s" + name + "UnaryOp], &uopMethods[Uop0s" + name + "UnaryOp], sizeof(typename UnaryOpF<T,0>::uopMethod),cudaMemcpyDeviceToHost));\n"
        end #statFunc
    end #kts
    
    if(locateFunction) 
        tempExp = exp 
        exp = "\nif(checkDebug(debugFtor))printf(\"invoked " + name + "'s operator()\\n\");\n" + exp
    end #locateFunction
    
    ./!append(fUnaryOp)
    .template<typename T> struct @{uncap}UnaryOp: public UnaryOpF<T,0> {
    .
    if(!kts)
        if(statFunc)
        .    using UnaryOpF<T,0>::fn;
        else
        .    using UnaryOpF<T,0>::operation;
        end #statFunc
    end #kts
        
    .    __host__ __device__ T operator()(T xi) const {
    .       @{exp}
    .    }
    
    if(locateFunction) 
        exp = tempExp
        exp = "if(checkDebug(debugFtor))printf(\"invoked operator"+name+"()\\n\");\n    " + exp
    end # locateFunction
    expStatic = exp
    
    if(!kts)
        ./!append(fBaseUnaryOp)
        if(statFunc) 
        .    static __host__ __device__ T operator@{name}(const UnaryOpF<T,0>& ref, T xi);
            expStatic = expStatic.gsub(/(\w*_ro\(\))/, 'ref.\1')
            allUnaryOpImpls += "template <typename T>  __host__ __device__ T UnaryOpF<T,0>::operator" + name+ "(const UnaryOpF<T,0>& ref, T xi) {\n    " + expStatic +"\n}\n\n"
        else
        .    __host__ __device__ T operator@{name}(T xi) const;
            allUnaryOpImpls += "template <typename T>  __host__ __device__ T UnaryOpF<T,0>::operator" + name+ "(T xi) const {\n    " + exp +"\n}\n\n"
        end #statFunc
    
        ./!append(fUnaryOp)
        .    __host__ __device__ void init(int currentDevice ) {
        if(!kts)
            if(statFunc) 
            .    #ifdef __CUDA_ARCH__
            .        ( (UnaryOpF<T,0>*)this)->fn = &UnaryOpF<T,0>::operator@{name};
            .    #else
            .        ( (UnaryOpF<T,0>*)this)->fn = FunctionTableMgr<T>::h_uop0sFunctions[currentDevice][Uop0s@{name}UnaryOp];
            .    #endif
            else
            .    #ifdef __CUDA_ARCH__
            .        ( (UnaryOpF<T,0>*)this)->operation = &UnaryOpF<T,0>::operator@{name};
            .    #else
            .        ( (UnaryOpF<T,0>*)this)->operation = MethodTableMgr<T>::h_uop0sMethods[currentDevice][Uop0s@{name}UnaryOp];
            .    #endif
            end #statFunc
        end #kts    
        .    }
    else
         .    __host__ __device__ void init(int currentDevice ) {}
    end # kts 
    ./!append(fUnaryOp)
    .}; // end @{uncap}UnaryOp
    .
end #do

if(!kts)
    . 
    #end findMethod
    ./!append(fMethodTableMgr)
    .}
    # close unaryOp enum 
    . /!append(fEnum)
    .    Uop0sLast
    .};  // UopOs Enum
end #kts





./!append(fUnaryOp)
./*
. *    1-d state unary ops
. */
.



if(!kts)
    # finder preamble
    ./!append(fMethodTableMgr)
    .
    ./*
    . * Store the device-side addresses of unary op functors with 1d state
    . */
    if(statFunc) 
        .template <typename T> __global__ void findUop1sFunctions(
        .        typename UnaryOpF<T,1>::uopFunction *uopFunctions) {
        .       if(checkDebug(debugFtor))printf("findUop1sFunctions uopFunctions %p\n", uopFunctions);
    else
        .template <typename T> __global__ void findUop1sMethods(
        .        typename UnaryOpF<T,1>::uopMethod *uopMethods) {
        .       if(checkDebug(debugFtor))printf("findUop1sMethods uopMethods %p\n", uopMethods);
    end #statFunc
    # create 1 template
    . /!append(fBaseUnaryOp)
    .};  // uop1s base template
    .
    .template<typename T> struct UnaryOpF<T,1>: public CuFunctor<T, 1> {
    .
    uopm = uopMethodDec[0] + "1" + uopMethodDec[1]
    .&{uopm}
    .
end #kts
./!append(fUnaryOp)

nameExps = [
    ["Pow", "exponent", "return powf(xi, exponent);"],
    ["Scale", "multiplicand", "return (xi * multiplicand);"],
    ["Translation", "addend", "return (xi + addend);"],
    ["SubFrom", "source", "return (source - xi);"],
    ["Divisible", "divisor", "return (divisor / xi) * xi == divisor ? xi : 0;"],
    ["DivSqrt", "divisor", "return static_cast<T>(sqrt(xi / divisor));"],
    ["Lt", "comp", "return (xi < comp);"],
    ["Lte", "comp", "return (xi <= comp);"],
    ["Gt", "comp", "return (xi > comp);"],
    ["Gte", "comp", "return (xi >= comp);"],
    ["Eq", "comp", "return (xi == comp);"],
    ["Neq", "comp", "return (xi != comp);"],
        ]
        
# setupXsMethodTables will copy the device-side member function pointer to host-side arrays 
if(statFunc) 
    setup1sFunctionTables = ""
else
    setup1sMethodTables = ""
end

if(!kts)
    # create enum
    . /!append(fEnum)
    .enum UnaryOp1sMethods {
end
        
nameExps.each do |nameExp|
    name = nameExp[0]
    uncap = name.uncapitalize
    prop = nameExp[1]
    exp = nameExp[2]
    
    if(!kts)
        # write enum
        . /!append(fEnum)
        .    Uop1s@{name}UnaryOp,
        # write finder
        . /!append(fMethodTableMgr)
    
        if(statFunc) 
        .    uopFunctions[Uop1s@{name}UnaryOp] = &UnaryOpF<T,1>::operator@{name};
        else
        .    uopMethods[Uop1s@{name}UnaryOp] = &UnaryOpF<T,1>::operator@{name};
        end #statFunc
        # add method copy
        if(statFunc) 
            setup1sFunctionTables += "    checkCudaErrors(cudaMemcpy(&FunctionTableMgr<T>::h_uop1sFunctions[device][Uop1s" + name + "UnaryOp], &uopFunctions[Uop1s" + name + "UnaryOp], sizeof(typename UnaryOpF<T,1>::uopFunction),cudaMemcpyDeviceToHost));\n"
        else
            setup1sMethodTables += "    checkCudaErrors(cudaMemcpy(&MethodTableMgr<T>::h_uop1sMethods[device][Uop1s" + name + "UnaryOp], &uopMethods[Uop1s" + name + "UnaryOp], sizeof(typename UnaryOpF<T,1>::uopMethod),cudaMemcpyDeviceToHost));\n"
        end #statFunc
    end #!kts
    
    ./!append(fUnaryOp)
    .template<typename T> struct @{uncap}UnaryOp: public UnaryOpF<T,1> {
    
    if(!kts)
        if(statFunc) 
        .    using UnaryOpF<T,1>::fn;
        else
        .    using UnaryOpF<T,1>::operation;
        end #statFunc
    end #kts
    exp = exp.gsub(prop, prop + "_ro()")
    .    __host__ __device__ inline T&  @{prop}() { return CuFunctor<T,1>::state; }
    .    __host__ __device__ inline const T& @{prop}_ro() const { return CuFunctor<T,1>::state; }
    .
    if(!allUnaryOpAccs.include?(prop+"_ro"))  
       allUnaryOpAccs[allUnaryOpAccs.length] = prop+"_ro"
        if(!kts)
        ./!append(fBaseUnaryOp)
        .    __host__ __device__ T&  @{prop}();
        .    __host__ __device__ const T&  @{prop}_ro() const;
                allUnaryOpImpls += "template <typename T> __host__ __device__ T&  UnaryOpF<T,1>::"+prop + "() { return CuFunctor<T,1>::state; };\n"
                allUnaryOpImpls += "template <typename T> __host__ __device__ const T& UnaryOpF<T,1>::"+prop + "_ro() const { return CuFunctor<T,1>::state; };\n"
        end # kts
    end # !allUnaryOpAccs.include?
    
    if(locateFunction) 
        tempExp = exp 
        exp = "\nif(checkDebug(debugFtor))printf(\"invoked " + name + "'s operator()\\n\");\n" + exp
    end #locateFunction
    
    ./!append(fUnaryOp)
    .    __host__ __device__ T operator()(T xi) const {
    .        @{exp}
    .    }
    
    if(locateFunction) 
        exp = tempExp
        exp = "if(checkDebug(debugFtor))printf(\"invoked operator"+name+"()\\n\");\n    " + exp
    end #locateFunction
    expStatic = exp
    
    if(!kts) 
        ./!append(fBaseUnaryOp)
        if(statFunc) 
            .    static __host__ __device__ T operator@{name}(const UnaryOpF<T,1>& ref, T xi);
                    expStatic = expStatic.gsub(/(\w*_ro\(\))/, 'ref.\1')
                    allUnaryOpImpls += "template <typename T>  __host__ __device__ T UnaryOpF<T,1>::operator" + name+ "(const UnaryOpF<T,1>& ref, T xi) {\n    " + expStatic +"\n}\n\n"
        else
        .    __host__ __device__ T operator@{name}(T xi) const;
                allUnaryOpImpls += "template <typename T> __host__ __device__ T UnaryOpF<T,1>::operator" + name+ "(T xi) const {\n    " + exp +"\n}\n\n"
        end #statFunc
    end #kts    
    ./!append(fUnaryOp)
    .    __host__ __device__ void init(int currentDevice, T _@{prop} = (T)0 ) {
    if(!kts)
        if(statFunc) 
        .    #ifdef __CUDA_ARCH__
        .        ( (UnaryOpF<T,1>*)this)->fn =  &UnaryOpF<T,1>::operator@{name};
        .    #else
        .        ( (UnaryOpF<T,1>*)this)->fn =  FunctionTableMgr<T>::h_uop1sFunctions[currentDevice][Uop1s@{name}UnaryOp];
        .    #endif
        else
        .    #ifdef __CUDA_ARCH__
        .        ( (UnaryOpF<T,1>*)this)->operation =  &UnaryOpF<T,1>::operator@{name};
        .    #else
        .        ( (UnaryOpF<T,1>*)this)->operation =  MethodTableMgr<T>::h_uop1sMethods[currentDevice][Uop1s@{name}UnaryOp];
        .    #endif
        end #statFunc
    end #kts
    .        @{prop}() = _@{prop};
    .    }
    ./!append(fUnaryOp)
    .}; // end @{uncap}UnaryOp
    . 
    
#
end # ----------------do  1-d state unary ops--------------------------------------------
#

allUnaryOpAccs=""
if(!kts) 
    ./!append(fMethodTableMgr)
    .}
    # close unaryOp enum 
    . /!append(fEnum)
    .    Uop1sLast
    .}; // uop1s enum

end



./!append(fUnaryOp)
./*
. *    2-d state unary ops
. */
.




if(!kts) 

    # finder preamble
    ./!append(fMethodTableMgr)
    .
    ./*
    . * Store the device-side addresses of unary op functors with 2d state
    . */
    if(statFunc) 
        .template <typename T> __global__ void findUop2sFunctions(
        .        typename UnaryOpF<T,2>::uopFunction *uopFunctions) {
        .       if(checkDebug(debugFtor))printf("findUop2sFunctions uopFunctions %p\n", uopFunctions);
    else
        .template <typename T> __global__ void findUop2sMethods(
        .        typename UnaryOpF<T,2>::uopMethod *uopMethods) {
        .       if(checkDebug(debugFtor))printf("findUop2sMethods uopMethods %p\n", uopMethods);
    end #statFunc
    
    # create 2 template
    . /!append(fBaseUnaryOp)
    .};  // base uop1s template
    .
    .template<typename T> struct UnaryOpF<T,2>: public CuFunctor<T, 2> {
    .
    uopm = uopMethodDec[0] + "2" + uopMethodDec[1]
    .&{uopm}
    .
end #kts

nameExps = [
    ["MutuallyDivisible", "divisor1", "divisor2",
    """return ((divisor1 / xi) * xi == divisor1)
        && ((divisor2 / xi) * xi == divisor2) ? xi : 0;"""
    ],
    ["AlmostEq",  "comp", "epsilon", "return fabs(xi - comp) < epsilon;"],
    ["NotAlmostEq", "comp", "epsilon",  "return (fabs(xi - comp) > epsilon);"],
         ]
        
# setupXsMethodTables will copy the device-side member function pointer to host-side arrays 
if(statFunc) 
    setup2sFunctionTables = ""
else
    setup2sMethodTables = ""
end #statFunc
    
if(!kts)
    # create enum
    . /!append(fEnum)
    .enum UnaryOp2sMethods {
end

nameExps.each do |nameExp|
    name = nameExp[0]
    uncap = name.uncapitalize
    prop1 = nameExp[1]
    prop2 = nameExp[2]
    exp = nameExp[3]
    
    if(!kts)
        # write enum
        . /!append(fEnum)
        .    Uop2s@{name}UnaryOp,
        # write finder
        . /!append(fMethodTableMgr)
        
        if(statFunc) 
        .    uopFunctions[Uop2s@{name}UnaryOp] = &UnaryOpF<T,2>::operator@{name};
        else
        .    uopMethods[Uop2s@{name}UnaryOp] = &UnaryOpF<T,2>::operator@{name};
        end #statFunc
    
        ./!append(fUnaryOp)
        # add method copy
        
        if(statFunc) 
            setup2sFunctionTables += "    checkCudaErrors(cudaMemcpy(&FunctionTableMgr<T>::h_uop2sFunctions[device][Uop2s" + name + "UnaryOp], &uopFunctions[Uop2s" + name + "UnaryOp], sizeof(typename UnaryOpF<T,2>::uopFunction),cudaMemcpyDeviceToHost));\n"
        else
            setup2sMethodTables += "    checkCudaErrors(cudaMemcpy(&MethodTableMgr<T>::h_uop2sMethods[device][Uop2s" + name + "UnaryOp], &uopMethods[Uop2s" + name + "UnaryOp], sizeof(typename UnaryOpF<T,2>::uopMethod),cudaMemcpyDeviceToHost));\n"
        end #statFunc
    end #kts
    
    if(locateFunction) 
        tempExp = exp 
        exp = "\nif(checkDebug(debugFtor))printf(\"invoked " + name + "'s operator()\\n\");\n" + exp
    end #locate 
    
    ./!append(fUnaryOp)
    .template<typename T> struct @{uncap}UnaryOp: public UnaryOpF<T,2> {
    
    if(!kts)
        if(statFunc) 
        .    using UnaryOpF<T,2>::fn;
        else
        .    using UnaryOpF<T,2>::operation;
        end #statFunc
    end #kts
    
    exp = exp.gsub(prop1, prop1 + "_ro()")
    exp = exp.gsub(prop2, prop2 + "_ro()")
    
    .    __host__ __device__ inline T&  @{prop1}() { return CuFunctor<T,2>::state.x; }
    .    __host__ __device__ inline const T& @{prop1}_ro() const { return CuFunctor<T,2>::state.x; }
    .    __host__ __device__ inline T&  @{prop2}() { return CuFunctor<T,2>::state.y; }
    .    __host__ __device__ inline const T& @{prop2}_ro() const { return CuFunctor<T,2>::state.y; }
    .
    .    __host__ __device__ T operator()(T xi) const {
    .        @{exp}
    .    }
    
    if(!kts)
        if(!allUnaryOpAccs.include?(prop1+"_ro"))  
            allUnaryOpAccs[allUnaryOpAccs.length] = prop1+"_ro"
        ./!append(fBaseUnaryOp)
        .    __host__ __device__ inline T&  @{prop1}();
        .    __host__ __device__ inline const T&  @{prop1}_ro() const;
            allUnaryOpImpls += "template<typename T> __host__ __device__ T&  UnaryOpF<T,2>::"+prop1 + "() { return CuFunctor<T,2>::state.x; };\n"
            allUnaryOpImpls += "template<typename T> __host__ __device__ const T&  UnaryOpF<T,2>::"+prop1 + "_ro() const { return CuFunctor<T,2>::state.x; };\n"
        end #!allUnaryOpAccs.include?(prop1
        
        if(!allUnaryOpAccs.include?(prop2+"_ro"))  
            allUnaryOpAccs[allUnaryOpAccs.length] = prop2+"_ro"
        ./!append(fBaseUnaryOp)
        .    __host__ __device__ inline T&  @{prop2}();
        .    __host__ __device__ inline const T& @{prop2}_ro() const;
            allUnaryOpImpls += "template<typename T> __host__ __device__ T& UnaryOpF<T,2>::"+prop2 + "() { return CuFunctor<T,2>::state.y; };\n"
            allUnaryOpImpls += "template<typename T> __host__ __device__ const T& UnaryOpF<T,2>::"+prop2 + "_ro() const { return CuFunctor<T,2>::state.y; };\n\n"
        end #!allUnaryOpAccs.include?(prop2
        
        ./!append(fBaseUnaryOp)
        .
        if(locateFunction) 
            exp = tempExp
            exp = "if(checkDebug(debugFtor))printf(\"invoked operator"+name+"()\\n\");\n    " + exp
        end #locateFunction
        expStatic = exp
        
        if(statFunc) 
        .    static __host__ __device__ T operator@{name}(const UnaryOpF<T,2>& ref,T xi) ;
            expStatic = expStatic.gsub(/(\w*_ro\(\))/, 'ref.\1')
            allUnaryOpImpls += "template <typename T>  __host__ __device__ T UnaryOpF<T,2>::operator" + name+ "(const UnaryOpF<T,2>& ref, T xi) {\n    " + expStatic +"\n}\n\n"
        else
        .    __host__ __device__ T operator@{name}(T xi) const;
            allUnaryOpImpls += "template<typename T> __host__ __device__ T UnaryOpF<T,2>::operator" + name+ "(T xi) const {\n    " + exp +"\n}\n\n"
        end #statFunc
    end    
    ./!append(fUnaryOp)
    .    __host__ __device__ void init(int currentDevice, T _@{prop1} = (T)0, T _@{prop2} = (T)0 ) {
    if(!kts)
        if(statFunc) 
        .    #ifdef __CUDA_ARCH__
        .        ( (UnaryOpF<T,2>*)this)->fn =  &UnaryOpF<T,2>::operator@{name};
        .    #else
        .        ( (UnaryOpF<T,2>*)this)->fn =  FunctionTableMgr<T>::h_uop2sFunctions[currentDevice][Uop2s@{name}UnaryOp];
        .    #endif
        else
        .    #ifdef __CUDA_ARCH__
        .        ( (UnaryOpF<T,2>*)this)->operation =  &UnaryOpF<T,2>::operator@{name};
        .    #else
        .        ( (UnaryOpF<T,2>*)this)->operation =  MethodTableMgr<T>::h_uop2sMethods[currentDevice][Uop2s@{name}UnaryOp];
        .    #endif
        end #statFunc
    end #kts
    .        @{prop1}() = _@{prop1};
    .        @{prop2}() = _@{prop2};
    .    }
    .
./!append(fUnaryOp)
.}; // @{uncap}UnaryOp
#
end  # ------------------do of 2d unary ops------------------------------------------
#

if(!kts)
    # write T,2 unary op
    allUnaryOpAccs=""
    ./!append(fBaseUnaryOp)
    .};  // base uop2s template
    .
    .&{allUnaryOpImpls}
    .
    ./!append(fMethodTableMgr)
    .}
    # close unaryOp enum 
    . /!append(fEnum)
    .    Uop2sLast
    .}; // uop2s enum
end




./!output(fUnaryOpIdx)
./*
. *  
. *  UnaryOpIndex.h
. *  (fillers)  
. *  Generated by ribosome at @{runTime}
. *
. */
.
.#pragma once

if(!kts)
    .#include "BaseUnaryOpIndexF_Gen.h"
    ./!output(fBaseIop)
    ./*
    .&{copyrightText}
    . *
    . *  BaseUnaryOpIndexF_Gen.h
    . *  base functor that operates on a single input (of same datatype as state and output)
    . *  Generated by ribosome at @{runTime}
    . *
    . */
    .#pragma once
    .#include "CuFunctor.h"
    .
else
    .#include "CuFunctor.h"
end

if(statFunc) 
    iopMethodDec=
     ["    typedef T (*iopFunction)(const UnaryOpIndexF<T," ,""">&,ulong);
    iopFunction fn;

    __host__ __device__ T operator()(ulong idx) {
        return  (*this->fn)(*this,idx);
    }"""]
else
    iopMethodDec=
     ["    typedef T (UnaryOpIndexF<T," ,""">::*iopMethod)(ulong idx)const;
    iopMethod operation;
    
    __host__ __device__ T operator()(ulong idx) const {
        return  (this->*operation)(idx);
    }"""]
end #statFunc


.template<typename T,int StateDim> struct UnaryOpIndexF : public CuFunctor<T,StateDim> {
.
iopm = iopMethodDec[0] + "StateDim" + iopMethodDec[1]
if(!kts) 
    .    // this member will hold a pointer to the subclass's impl of the operator()(ulong) method
    .&{iopm}
    .
    .    __host__ __device__ void init(int currDev) {
    
    if(statFunc) 
    .        fn = 0;
    else
    .        operation = 0;
    end #statFunc
    
    .    }
else
    .    __host__ __device__ T operator()(ulong idx) { return 11;}
    .    __host__ __device__ void init(int currDev) {}
end #kts
.};  // UnaryOpIndexF
.

if(!kts)
    # finder preamble
    ./!append(fMethodTableMgr)
    .
    ./*
    . * Store the device-side addresses of stateless unary op index functors
    . */
    if(statFunc) 
        .template <typename T> __global__ void findIop0sFunctions(
        .       typename UnaryOpIndexF<T,0>::iopFunction *iopFunctions) {
        .       if(checkDebug(debugFtor))printf("findIop0sFunctions iopFunctions %p\n", iopFunctions);
    else
        .template <typename T> __global__ void findIop0sMethods(
        .       typename UnaryOpIndexF<T,0>::iopMethod *iopMethods) {
        .       if(checkDebug(debugFtor))printf("findIop0sMethods iopMethods %p\n", iopMethods);
    end #statFunc
    
    # create 0 template
    . /!append(fBaseIop)
    .template<typename T> struct UnaryOpIndexF<T,0>: public CuFunctor<T, 0> {
    .
    iopm = iopMethodDec[0] + "0" + iopMethodDec[1]
    .&{iopm}
end #kts


nameExps = [
    ["OneOver",  "return 1. / static_cast<T>(idx);"],
   ["Step",  "return 1. / static_cast<T>(1 + idx);"],
        ]
        
if(statFunc) 
    setup0sFunctionTables += "\n"
else
    setup0sMethodTables += "\n"
end #statFunc

allIopAccs=""
allIopDecs=""
allIopImpls=""


if(!kts)
    # create enum
    . /!append(fEnum)
    .enum IndexOp0sMethods {
end

nameExps.each do |nameExp|
    name = nameExp[0]
    uncap = name.uncapitalize
    exp = nameExp[1]
    
    if(!kts) 
        # write enum
        . /!append(fEnum)
        .    Iop0s@{name}Filler,
        # write finder
        . /!append(fMethodTableMgr)
        if(statFunc) 
        .    iopFunctions[Iop0s@{name}Filler] = &UnaryOpIndexF<T,0>::operator@{name};
        .    if(checkDebug(debugFtor))printf("found iopFunctions[Iop0s@{name}Filler] %p\n", &UnaryOpIndexF<T,0>::operator@{name});
        .    if(checkDebug(debugFtor))printf(" &@{uncap}Filler<T>::operator() %p &iopFunctions[Iop0s@{name}Filler] %p\n", &@{uncap}Filler<T>::operator(), &iopFunctions[Iop0s@{name}Filler]);
        else
        .    iopMethods[Iop0s@{name}Filler] = &UnaryOpIndexF<T,0>::operator@{name};
        .    if(checkDebug(debugFtor))printf("found iopMethods[Iop0s@{name}Filler] %p\n", &UnaryOpIndexF<T,0>::operator@{name});
        .    if(checkDebug(debugFtor))printf(" &@{uncap}Filler<T>::operator() %p &iopMethods[Iop0s@{name}Filler] %p\n", &@{uncap}Filler<T>::operator(), &iopMethods[Iop0s@{name}Filler]);
        end #statFunc
    end #kts
    
    if(!kts) 
        # add method copy
        if(statFunc) 
            setup0sFunctionTables += "    checkCudaErrors(cudaMemcpy(&FunctionTableMgr<T>::h_iop0sFunctions[device][Iop0s" + name + "Filler], &iopFunctions[Iop0s" + name + "Filler], sizeof(typename UnaryOpIndexF<T,0>::iopFunction),cudaMemcpyDeviceToHost));\n"
        else
            setup0sMethodTables += "    checkCudaErrors(cudaMemcpy(&MethodTableMgr<T>::h_iop0sMethods[device][Iop0s" + name + "Filler], &iopMethods[Iop0s" + name + "Filler], sizeof(typename UnaryOpIndexF<T,0>::iopMethod),cudaMemcpyDeviceToHost));\n"
        end #statFunc
    end #kts
    
    if(locateFunction) 
        tempExp = exp 
        exp = "\nif(checkDebug(debugFtor))printf(\"invoked " + name + "'s operator()\\n\");\n" + exp
    end #locateFunction
    
    ./!append(fUnaryOpIdx)
    .template<typename T> struct @{uncap}Filler: public UnaryOpIndexF<T,0> {
    if(!kts) 
        if(statFunc) 
        .    using UnaryOpIndexF<T,0>::fn;
        else
        .    using UnaryOpIndexF<T,0>::operation;
        end #statFunc
    end #kts
    
    .    __host__ __device__ T operator()(ulong idx) const {
    .        @{exp}
    .    }
    
    if(locateFunction) 
        exp = tempExp
        exp = "if(checkDebug(debugFtor))printf(\"invoked operator"+name+"()\\n\");\n    " + exp
    end #locateFunction
    expStatic = exp
    
    if(!kts) 
        ./!append(fBaseIop)
        if(statFunc) 
        .    static __host__ __device__ T operator@{name}(const UnaryOpIndexF<T,0>& ref, ulong idx);
            expStatic = expStatic.gsub(/(\w*_ro\(\))/, 'ref.\1')
            allIopImpls += "template <typename T> __host__ __device__ T UnaryOpIndexF<T,0>::operator" + name+ "(const UnaryOpIndexF<T,0>& ref, ulong idx) {\n    " + expStatic +"\n}\n\n"
        else
        .    __host__ __device__ T operator@{name}(ulong idx) const;
            allIopImpls += "template <typename T>  __host__ __device__ T UnaryOpIndexF<T,0>::operator" + name+ "(ulong idx) const {\n    " + exp +"\n}\n\n"
        end #statFunc
    end #kts
    
    ./!append(fUnaryOpIdx)
    
    .    __host__ __device__ void init(int currentDevice ) {
    if(!kts) 
        if(statFunc) 
        .    #ifdef __CUDA_ARCH__
        .        ( (UnaryOpIndexF<T,0>*)this)->fn = &UnaryOpIndexF<T,0>::operator@{name};
        .    #else
        .        ( (UnaryOpIndexF<T,0>*)this)->fn =  FunctionTableMgr<T>::h_iop0sFunctions[currentDevice][Iop0s@{name}Filler];
        .    #endif
        else
        .    #ifdef __CUDA_ARCH__
        .        ( (UnaryOpIndexF<T,0>*)this)->operation = &UnaryOpIndexF<T,0>::operator@{name};
        .    #else
        .        ( (UnaryOpIndexF<T,0>*)this)->operation =  MethodTableMgr<T>::h_iop0sMethods[currentDevice][Iop0s@{name}Filler];
        .    #endif
        end #statFunc
    end #kts
    .    }
    .};  // @{uncap}Filler
    .
    
end  # ----------------------- do stateless filleurs -------------------------------------------------

if(!kts) 
    ./!append(fMethodTableMgr)
    .}
    
    # close unaryOp enum 
    . /!append(fEnum)
    .    Iop0sLast
    .}; // iop0s enum
end



./!append(fUnaryOpIdx)
./*
. *     1-d state fillers  
. */

if(!kts)
    # finder preamble
    ./!append(fMethodTableMgr)
    .
    ./*
    . * Store the device-side addresses of unary op index functors with 1d state
    . */
    
    if(statFunc) 
        .template <typename T> __global__ void findIop1sFunctions(
        .       typename UnaryOpIndexF<T,1>::iopFunction *iopFunctions) {
        .       if(checkDebug(debugFtor))printf("findIop1sFunctions iopFunctions %p\n", iopFunctions);
    else
        .template <typename T> __global__ void findIop1sMethods(
        .       typename UnaryOpIndexF<T,1>::iopMethod *iopMethods) {
        .       if(checkDebug(debugFtor))printf("findIop1sMethods iopMethods %p\n", iopMethods);
    end #statFunc
    
    # create 1 template
    . /!append(fBaseIop)
    .};  // base iop1s template
    .
    . // 1d
    .template<typename T> struct UnaryOpIndexF<T,1>: public CuFunctor<T, 1> {
    .
    iopm = iopMethodDec[0] + "1" + iopMethodDec[1]
    .&{iopm}
    .
end #kts

# separate from 1s unary ops
if(statFunc) 
    setup1sFunctionTables += "\n" 
else
    setup1sMethodTables += "\n" 
end #statFunc

nameExps = [
    ["Sequence",  "phase", "return static_cast<T>(idx + phase);"],
     ["Const", "value", "return value;"],
       ["Pow", "base", 
       """if (idx == 0) {
        return (T) 1;
    }
    if (idx == 1) {
        return base;
    }
    return powf( base, idx);"""],
        ]

if(!kts)
    # create enum
    ./!append(fEnum)
    .enum IndexOp1sMethods {
end

nameExps.each do |nameExp|
    name = nameExp[0]
    uncap = name.uncapitalize
    prop = nameExp[1]
    exp = nameExp[2]
    
    if(!kts)
        # write enum
        . /!append(fEnum)
        .    Iop1s@{name}Filler,
        # write finder
        . /!append(fMethodTableMgr)
            if(statFunc)
            .    iopFunctions[Iop1s@{name}Filler] = &UnaryOpIndexF<T,1>::operator@{name};
            .    if(checkDebug(debugFtor))printf("found iopFunctions[Iop1s@{name}Filler] %p\n", &UnaryOpIndexF<T,1>::operator@{name});
            else
            .    iopMethods[Iop1s@{name}Filler] = &UnaryOpIndexF<T,1>::operator@{name};
            .    if(checkDebug(debugFtor))printf("found iopMethods[Iop1s@{name}Filler] %p\n", &UnaryOpIndexF<T,1>::operator@{name});
            end # statFunc
    end #kts
    ./!append(fUnaryOpIdx)
    
    if(!kts)
        # add method copy
        if(statFunc) 
            setup1sFunctionTables += "    checkCudaErrors(cudaMemcpy(&FunctionTableMgr<T>::h_iop1sFunctions[device][Iop1s" + name + "Filler], &iopFunctions[Iop1s" + name + "Filler], sizeof(typename UnaryOpIndexF<T,1>::iopFunction),cudaMemcpyDeviceToHost));\n"
        else
            setup1sMethodTables += "    checkCudaErrors(cudaMemcpy(&MethodTableMgr<T>::h_iop1sMethods[device][Iop1s" + name + "Filler], &iopMethods[Iop1s" + name + "Filler], sizeof(typename UnaryOpIndexF<T,1>::iopMethod),cudaMemcpyDeviceToHost));\n"
        end #statFunc
    end #kts
    
    if(locateFunction) 
        tempExp = exp 
        exp = "\nif(checkDebug(debugFtor))printf(\"invoked " + name + "'s operator()\\n\");\n" + exp
    end #locate 
    expStatic=exp
    
    .template<typename T> struct @{uncap}Filler: public UnaryOpIndexF<T,1> {
    if(!kts)
        if(statFunc) 
       .    using UnaryOpIndexF<T,1>::fn;
        else
        .    using UnaryOpIndexF<T,1>::operation;
        end #statFunc
    end #kts
    
    exp = exp.gsub(prop, prop + "_ro()")
    .    __host__ __device__ inline T&  @{prop}() { return CuFunctor<T,1>::state; }
    .    __host__ __device__ inline const T& @{prop}_ro() const { return CuFunctor<T,1>::state; }
    .
    .    
    .    __host__ __device__ T operator()(ulong idx) const {
    .        @{exp}
    .    }
    
    if(!kts)
        ./!append(fBaseIop)
        if(!allIopAccs.include?(prop+"_ro"))  
            allIopAccs[allIopAccs.length] = prop+"_ro"
        .    __host__ __device__ T&  @{prop}();
        .    __host__ __device__ const T&  @{prop}_ro() const;
            allIopImpls += "template <typename T> __host__ __device__ T&  UnaryOpIndexF<T,1>::"+prop + "() { return CuFunctor<T,1>::state; };\n"
            allIopImpls += "template <typename T> __host__ __device__ const T& UnaryOpIndexF<T,1>::"+prop + "_ro() const { return CuFunctor<T,1>::state; };\n"
        end # !allIopAccs.include?(prop
        if(locateFunction) 
            exp = tempExp
            exp = "if(checkDebug(debugFtor))printf(\"invoked operator"+name+"()\\n\");\n    " + exp
        end #locate
        expStatic = exp
        
        if(statFunc) 
        .    static __host__ __device__ T operator@{name}(const UnaryOpIndexF<T,1>& ref, ulong idx);
                expStatic = expStatic.gsub(/(\w*_ro\(\))/, 'ref.\1')
                allIopImpls += "template <typename T> __host__ __device__ T UnaryOpIndexF<T,1>::operator" + name+ "(const UnaryOpIndexF<T,1>& ref, ulong idx) {\n    " + expStatic +"\n}\n\n"
        else
        .    __host__ __device__ T operator@{name}(ulong idx) const;
                allIopImpls += "template <typename T>  __host__ __device__ T UnaryOpIndexF<T,1>::operator" + name+ "(ulong idx) const {\n    " + exp +"\n}\n\n"
        end #statFunc
        
    end #kts    
    ./!append(fUnaryOpIdx)
    .    __host__ __device__ void init(int currentDevice, T _@{prop} = (T)0 ) {
    if(!kts)
        if(statFunc) 
        .    #ifdef __CUDA_ARCH__
        .        ( (UnaryOpIndexF<T,1>*)this)->fn = &UnaryOpIndexF<T,1>::operator@{name};
        .    #else
        .        ( (UnaryOpIndexF<T,1>*)this)->fn =  FunctionTableMgr<T>::h_iop1sFunctions[currentDevice][Iop1s@{name}Filler];
        .    #endif
        else
        .    #ifdef __CUDA_ARCH__
        .        ( (UnaryOpIndexF<T,1>*)this)->operation = &UnaryOpIndexF<T,1>::operator@{name};
        .    #else
        .        ( (UnaryOpIndexF<T,1>*)this)->operation =  MethodTableMgr<T>::h_iop1sMethods[currentDevice][Iop1s@{name}Filler];
        .    #endif
        end #statFunc
    end #kts
    .        @{prop}() = _@{prop};
    .    }
    
    ./!append(fUnaryOpIdx)
    .};  // @{uncap}Filler
    .
end # do 1d fills


./!append(fUnaryOpIdx)
./*
. *     2-d state fillers  
. */


if(!kts)
    ./!append(fMethodTableMgr)
    .}
    # close unaryOp enum 
    . /!append(fEnum)
    .    Iop1sLast
    .}; // iop1s enum

    # finder preamble
    ./!append(fMethodTableMgr)
    .
    ./*
    . * Store the device-side addresses of unary op index functors with 2d state
    . */
    if(statFunc) 
        .template <typename T> __global__ void findIop2sFunctions(
        .       typename UnaryOpIndexF<T,2>::iopFunction *iopFunctions) {
        .       if(checkDebug(debugFtor))printf("findIop1sFunctions iopFunctions %p\n", iopFunctions);
        else
        .template <typename T> __global__ void findIop2sMethods(
        .       typename UnaryOpIndexF<T,2>::iopMethod *iopMethods) {
        .       if(checkDebug(debugFtor))printf("findIop1sMethods iopMethods %p\n", iopMethods);
    end #statFunc
    # create 2 template
    allIopAccs=""
    . /!append(fBaseIop)
    .};  // base iop2s template
else
   ./!append(fUnaryOpIdx) 
end #kts
if(!kts)
    .
    .template<typename T> struct UnaryOpIndexF<T,2>: public CuFunctor<T, 2> {
    .
    iopm = iopMethodDec[0] + "2" + iopMethodDec[1]
    .&{iopm}
end

nameExps = [
    ["IncreasingColumns",  "start", "cols", 
        "return static_cast<T>(start + (idx % static_cast<ulong>(cols) ) );"],

    ["IncreasingRows",  "start", "rows", 
        "return static_cast<T>(start + (idx / static_cast<ulong>(rows)));"],

    ["SeqMod",  "phase", "mod", 
"""return static_cast<T>((idx + static_cast<ulong>(phase))
        % static_cast<ulong>(mod));"""],
    ["Diagonal",  "value", "dim", 
        "return (idx /static_cast<ulong>(dim) == idx % static_cast<ulong>(dim) ? value : 0);"],
    ["IsColumn",  "pitch", "column", 
        "return (idx % static_cast<ulong>(pitch) == static_cast<ulong>(column));"],
    ["IsRow",  "pitch", "row", 
        "return (idx / pitch == row);"],

        ]
       
if(!kts)  
    # create enum
    . /!append(fEnum)
    .enum IndexOp2sMethods {
end

nameExps.each do |nameExp|
    name = nameExp[0]
    uncap = name.uncapitalize
    prop1 = nameExp[1]
    prop2 = nameExp[2]
    exp = nameExp[3]
    
    if(!kts)
        # write enum
        . /!append(fEnum)
        .    Iop2s@{name}Filler,
        # write finder
        . /!append(fMethodTableMgr)
    
        if(statFunc) 
        .    iopFunctions[Iop2s@{name}Filler] = &UnaryOpIndexF<T,2>::operator@{name};
        .    if(checkDebug(debugFtor))printf("found iopFunctions[Iop2s@{name}Filler] %p\n", &UnaryOpIndexF<T,2>::operator@{name});
        else
        .    iopMethods[Iop2s@{name}Filler] = &UnaryOpIndexF<T,2>::operator@{name};
        .    if(checkDebug(debugFtor))printf("found iopMethods[Iop2s@{name}Filler] %p\n", &UnaryOpIndexF<T,2>::operator@{name});
        end #statFunc
    
        # add method copy
        if(statFunc) 
            setup2sFunctionTables += "    checkCudaErrors(cudaMemcpy(&FunctionTableMgr<T>::h_iop2sFunctions[device][Iop2s" + name + "Filler], &iopFunctions[Iop2s" + name + "Filler], sizeof(typename UnaryOpIndexF<T,2>::iopFunction),cudaMemcpyDeviceToHost));\n"
        else
            setup2sMethodTables += "    checkCudaErrors(cudaMemcpy(&MethodTableMgr<T>::h_iop2sMethods[device][Iop2s" + name + "Filler], &iopMethods[Iop2s" + name + "Filler], sizeof(typename UnaryOpIndexF<T,2>::iopMethod),cudaMemcpyDeviceToHost));\n"
        end #statFunc
    end #kts  
      
    if(locateFunction) 
        tempExp = exp 
        exp = "\nif(checkDebug(debugFtor))printf(\"invoked " + name + "'s operator()\\n\");\n" + exp
    end #lcoate 
    
    ./!append(fUnaryOpIdx)
    .template<typename T> struct @{uncap}Filler: public UnaryOpIndexF<T,2> {
    
    if(!kts)
        if(statFunc) 
        .    using UnaryOpIndexF<T,2>::fn;
        else
        .    using UnaryOpIndexF<T,2>::operation;
        end #statFunc
    end #kts   
    exp = exp.gsub(prop1, prop1 + "_ro()")
    exp = exp.gsub(prop2, prop2 + "_ro()")
    .    __host__ __device__ inline T&  @{prop1}() { return CuFunctor<T,2>::state.x; }
    .    __host__ __device__ inline const T& @{prop1}_ro() const { return CuFunctor<T,2>::state.x; }
    .    __host__ __device__ inline T&  @{prop2}() { return CuFunctor<T,2>::state.y; }
    .    __host__ __device__ inline const T& @{prop2}_ro() const { return CuFunctor<T,2>::state.y; }
    .
    .    __host__ __device__ T operator()(ulong idx) const {
    .        @{exp}
    .    }
    
    if(!kts) 
        . /!append(fBaseIop)
        if(!allIopAccs.include?(prop1+"_ro"))  
            allIopAccs[allIopAccs.length] = prop1+"_ro"
        .    __host__ __device__ T&  @{prop1}();
        .    __host__ __device__ const T&  @{prop1}_ro() const;
            allIopImpls += "template <typename T> __host__ __device__ T&  UnaryOpIndexF<T,2>::"+prop1 + "() { return CuFunctor<T,2>::state.x; };\n"
            allIopImpls += "template <typename T> __host__ __device__ const T& UnaryOpIndexF<T,2>::"+prop1 + "_ro() const { return CuFunctor<T,2>::state.x; };\n"
        end #!allIopAccs.include?(prop1
        
        if(!allIopAccs.include?(prop2+"_ro"))  
            allIopAccs[allIopAccs.length] = prop2+"_ro"
        .    __host__ __device__ T&  @{prop2}();
        .    __host__ __device__ const T&  @{prop2}_ro() const;
            allIopImpls += "template <typename T> __host__ __device__ T&  UnaryOpIndexF<T,2>::"+prop2 + "() { return CuFunctor<T,2>::state.y; };\n"
            allIopImpls += "template <typename T> __host__ __device__ const T& UnaryOpIndexF<T,2>::"+prop2 + "_ro() const { return CuFunctor<T,2>::state.y; };\n"
        end #!allIopAccs.include?(prop2
    
        if(locateFunction) 
            exp = tempExp
            exp = "if(checkDebug(debugFtor))printf(\"invoked operator"+name+"()\\n\");\n    " + exp
        end #locate
        expStatic = exp
        
        if(statFunc) 
        .    static __host__ __device__ T operator@{name}(const UnaryOpIndexF<T,2>& ref, ulong idx);
            expStatic = expStatic.gsub(/(\w*_ro\(\))/, 'ref.\1')
            allIopImpls += "template <typename T> __host__ __device__ T UnaryOpIndexF<T,2>::operator" + name+ "(const UnaryOpIndexF<T,2>& ref, ulong idx) {\n    " + expStatic +"\n}\n\n"
        else
        .    __host__ __device__ T operator@{name}(ulong idx) const;
            allIopImpls += "template <typename T>  __host__ __device__ T UnaryOpIndexF<T,2>::operator" + name+ "(ulong idx) const {\n    " + exp +"\n}\n\n"
        end #statFunc
    end #kts
        
    ./!append(fUnaryOpIdx)
    .    __host__ __device__ void init(int currentDevice, T _@{prop1} = (T)0 , T _@{prop2} = (T)0 ) {
    if(!kts)
        if(statFunc) 
        .   #ifdef __CUDA_ARCH__
        .         ( (UnaryOpIndexF<T,2>*)this)->fn  = &UnaryOpIndexF<T,2>::operator@{name};
        .    #else
        .         ( (UnaryOpIndexF<T,2>*)this)->fn =  FunctionTableMgr<T>::h_iop2sFunctions[currentDevice][Iop2s@{name}Filler];
        .    #endif
        else
        .   #ifdef __CUDA_ARCH__
        .         ( (UnaryOpIndexF<T,2>*)this)->operation  = &UnaryOpIndexF<T,2>::operator@{name};
        .    #else
        .         ( (UnaryOpIndexF<T,2>*)this)->operation =  MethodTableMgr<T>::h_iop2sMethods[currentDevice][Iop2s@{name}Filler];
        .    #endif
        end #statFunc
    end #kts
    .        @{prop1}() = _@{prop1};
    .        @{prop2}() = _@{prop2};
    .    }
    .};  // @{uncap}Filler
    .
end #do 2d filler

if(!kts)
    ./!append(fMethodTableMgr)
    .}
    # close unaryOp enum 
    . /!append(fEnum)
    .    Iop2sLast
    .};  // iop2s enum 
end




./!append(fUnaryOpIdx)
./*
. *     3-d state fillers  
. */


if(!kts)
    # finder preamble
    ./!append(fMethodTableMgr)
    .
    ./*
    . * Store the device-side addresses of unary op index functors with 3d state
    . */
    if(statFunc) 
    .template <typename T> __global__ void findIop3sFunctions(
    .       typename UnaryOpIndexF<T,3>::iopFunction *iopFunctions) {
    .       if(checkDebug(debugFtor))printf("findIop3sFunctions iopFunctions %p\n", iopFunctions);
    else
    .template <typename T> __global__ void findIop3sMethods(
    .       typename UnaryOpIndexF<T,3>::iopMethod *iopMethods) {
    .       if(checkDebug(debugFtor))printf("findIop3sMethods iopMethods %p\n", iopMethods);
    end #statFunc

    # create 3 template
    allIopAccs=""
    . /!append(fBaseIop)
    .};  // base iop3s template
    .
    .template<typename T> struct UnaryOpIndexF<T,3>: public CuFunctor<T, 3> {
    .
    iopm = iopMethodDec[0] + "3" + iopMethodDec[1]
    .&{iopm}
    .
end #kts

nameExps = [
    ["Sin",  "amplitude", "period", "phase",
        "return static_cast<T>(amplitude * ::sin(2. * Pi *  (idx - phase)/ period ));"],

    ["Cos",  "amplitude", "period", "phase",
        "return static_cast<T>(amplitude * ::cos(2. * Pi * (idx +  phase) /  period));"],

    ["Span",  "start", "end", "steps",
        "return static_cast<T>(start + idx * (end- start) / steps);"],
        ]

if(!kts)
    # create enum
    . /!append(fEnum)
    .enum IndexOp3sMethods {
    # setupXsMethodTables will copy the device-side member function pointer to host-side arrays 
    if(statFunc) 
        setup3sFunctionTables = ""
    else
        setup3sMethodTables = ""
    end #statFunc
end
        
nameExps.each do |nameExp|
    name = nameExp[0]
    uncap = name.uncapitalize
    prop1 = nameExp[1]
    prop2 = nameExp[2]
    prop3 = nameExp[3]
    exp = nameExp[4]
    
    if(!kts)
        # write enum
        . /!append(fEnum)
        .    Iop3s@{name}Filler,
        # write finder
        . /!append(fMethodTableMgr)
        if(statFunc)
        .    iopFunctions[Iop3s@{name}Filler] = &UnaryOpIndexF<T,3>::operator@{name};
        .    if(checkDebug(debugFtor))printf("found iopFunctions[Iop3s@{name}Filler] %p\n", &UnaryOpIndexF<T,3>::operator@{name});
        else
        .    iopMethods[Iop3s@{name}Filler] = &UnaryOpIndexF<T,3>::operator@{name};
        .    if(checkDebug(debugFtor))printf("found iopMethods[Iop3s@{name}Filler] %p\n", &UnaryOpIndexF<T,3>::operator@{name});
        end #statFunc
    
        # add method copy
        if(statFunc)
            setup3sFunctionTables += "    checkCudaErrors(cudaMemcpy(&FunctionTableMgr<T>::h_iop3sFunctions[device][Iop3s" + name + "Filler], &iopFunctions[Iop3s" + name + "Filler], sizeof(typename UnaryOpIndexF<T,3>::iopFunction),cudaMemcpyDeviceToHost));\n"
        else
            setup3sMethodTables += "    checkCudaErrors(cudaMemcpy(&MethodTableMgr<T>::h_iop3sMethods[device][Iop3s" + name + "Filler], &iopMethods[Iop3s" + name + "Filler], sizeof(typename UnaryOpIndexF<T,3>::iopMethod),cudaMemcpyDeviceToHost));\n"
        end #statFunc
        
        if(locateFunction) 
            tempExp = exp 
            exp = "\nif(checkDebug(debugFtor))printf(\"invoked " + name + "'s operator()\\n\");\n" + exp
        end #locate 
    end #kts
    
    ./!append(fUnaryOpIdx)
    .template<typename T> struct @{uncap}Filler: public UnaryOpIndexF<T,3> {
    
    exp = exp.gsub(prop1, prop1 + "_ro()")
    exp = exp.gsub(prop2, prop2 + "_ro()")
    exp = exp.gsub(prop3, prop3 + "_ro()")
    if(!kts)
        if(statFunc) 
        .    using UnaryOpIndexF<T,3>::fn;
        else
        .    using UnaryOpIndexF<T,3>::operation;
        end #statFunc
    end #kts
    .    __host__ __device__ inline T&  @{prop1}() { return CuFunctor<T,3>::state.x; }
    .    __host__ __device__ inline const T& @{prop1}_ro() const { return CuFunctor<T,3>::state.x; }
    .    __host__ __device__ inline T&  @{prop2}() { return CuFunctor<T,3>::state.y; }
    .    __host__ __device__ inline const T& @{prop2}_ro() const { return CuFunctor<T,3>::state.y; }
    .    __host__ __device__ inline T&  @{prop3}() { return CuFunctor<T,3>::state.z; }
    .    __host__ __device__ inline const T& @{prop3}_ro() const { return CuFunctor<T,3>::state.z; }
    .
    .    __host__ __device__ T operator()(ulong idx) const {
    .        @{exp}
    .    }
    
    if(!kts)
        . /!append(fBaseIop)
        if(!allIopAccs.include?(prop1+"_ro"))  
            allIopAccs[allIopAccs.length] = prop1+"_ro"
        .    __host__ __device__ T&  @{prop1}();
        .    __host__ __device__ const T&  @{prop1}_ro() const;
            allIopImpls += "template <typename T> __host__ __device__ T&  UnaryOpIndexF<T,3>::"+prop1 + "() { return CuFunctor<T,3>::state.x; };\n"
            allIopImpls += "template <typename T> __host__ __device__ const T& UnaryOpIndexF<T,3>::"+prop1 + "_ro() const { return CuFunctor<T,3>::state.x; };\n"
        end #!allIopAccs.include?(prop1
        
        if(!allIopAccs.include?(prop2+"_ro"))  
            allIopAccs[allIopAccs.length] = prop2+"_ro"
        .    __host__ __device__ T&  @{prop2}();
        .    __host__ __device__ const T&  @{prop2}_ro() const;
            allIopImpls += "template <typename T> __host__ __device__ T&  UnaryOpIndexF<T,3>::"+prop2 + "() { return CuFunctor<T,3>::state.y; };\n"
            allIopImpls += "template <typename T> __host__ __device__ const T& UnaryOpIndexF<T,3>::"+prop2 + "_ro() const { return CuFunctor<T,3>::state.y; };\n"
        end  #!allIopAccs.include?(prop2
        
        if(!allIopAccs.include?(prop3+"_ro"))  
            allIopAccs[allIopAccs.length] = prop3+"_ro"
        .    __host__ __device__ T&  @{prop3}();
        .    __host__ __device__ const T&  @{prop3}_ro() const;
            allIopImpls += "template <typename T> __host__ __device__ T&  UnaryOpIndexF<T,3>::"+prop3 + "() { return CuFunctor<T,3>::state.z; };\n"
            allIopImpls += "template <typename T> __host__ __device__ const T& UnaryOpIndexF<T,3>::"+prop3 + "_ro() const { return CuFunctor<T,3>::state.z; };\n"
        end #!allIopAccs.include?(prop3
        
        if(locateFunction) 
            exp = tempExp
            exp = "if(checkDebug(debugFtor))printf(\"invoked operator"+name+"()\\n\");\n    " + exp
        end #locate
        expStatic = exp
        
        if(statFunc) 
        .    static __host__ __device__ T operator@{name}(const UnaryOpIndexF<T,3>& ref, ulong idx);
            expStatic = expStatic.gsub(/(\w*_ro\(\))/, 'ref.\1')
            allIopImpls += "template <typename T> __host__ __device__ T UnaryOpIndexF<T,3>::operator" + name+ "(const UnaryOpIndexF<T,3>& ref, ulong idx) {\n    " + expStatic +"\n}\n\n"
        else
        .    __host__ __device__ T operator@{name}(ulong idx) const;
            allIopImpls += "template <typename T>  __host__ __device__ T UnaryOpIndexF<T,3>::operator" + name+ "(ulong idx) const {\n    " + exp +"\n}\n\n"
        end #statFunc
    end #kts 
        
    ./!append(fUnaryOpIdx)
    .    __host__ __device__ void init(int currentDevice, T _@{prop1} = (T)0 , T _@{prop2} = (T)0, T _@{prop3} = (T)0 ) {
    if(!kts)
        if(statFunc) 
        .    #ifdef __CUDA_ARCH__
        .        ( (UnaryOpIndexF<T,3>*)this)->fn = &UnaryOpIndexF<T,3>::operator@{name};
        .    #else
        .         ( (UnaryOpIndexF<T,3>*)this)->fn  =  FunctionTableMgr<T>::h_iop3sFunctions[currentDevice][Iop3s@{name}Filler];
        .    #endif
        else
        .    #ifdef __CUDA_ARCH__
        .        ( (UnaryOpIndexF<T,3>*)this)->operation = &UnaryOpIndexF<T,3>::operator@{name};
        .    #else
        .         ( (UnaryOpIndexF<T,3>*)this)->operation  =  MethodTableMgr<T>::h_iop3sMethods[currentDevice][Iop3s@{name}Filler];
        .    #endif
        end #statFunc
    end #kts
    .        @{prop1}() = _@{prop1};
    .        @{prop2}() = _@{prop2};
    .        @{prop3}() = _@{prop3};
    .    }
    .};   // @{uncap}Filler
    .
    #
end # ----------------------------------------- do 3d filler
#




#
# ============================ binary ops ==================================
#



./!output(fBinaryOp)
./*
.&{copyrightText}
. *
. *  BinaryOpF_Gen.h
. *  Generated by ribosome at @{runTime}
. *
. */
.
.#pragma once
.
if(!kts)
    .#include "BaseBinaryOpF_Gen.h"
else
    .#include "CuFunctor.h"
    .
    ./*
    . *     stateless binary ops
    . */
end

if(!kts) 
    # close last iop template
    . /!append(fBaseIop)
    .};  // base iop3s template
    .
    .&{allIopImpls}
    ./!append(fMethodTableMgr)
    .} // iop3s finder
    # close unaryOp enum 
    . /!append(fEnum)
    .    Iop3sLast
    .}; // iop3s enum

    ./!output(fBaseBop)
    ./*
    .&{copyrightText}
    . *
    . *  BaseBinaryOpF_Gen.h
    . *  base functor that operates on a two inputs (of same datatype as state and output)
    . *  Generated by ribosome at @{runTime}
    . *
    . */
    .#pragma once
    .#include "CuFunctor.h"
    .
    if(statFunc) 
        bopMethodDec=
         ["    typedef T (*bopFunction)(const BinaryOpF<T," ,""">&,T,T);
        bopFunction fn;
        
        __host__ __device__ T operator()(T xi1, T xi2) const {
            return  (*this->fn)(*this,xi1,xi2);
        }"""]
    else
        bopMethodDec=
         ["    typedef T (BinaryOpF<T," ,""">::*bopMethod)(T,T)const;
        bopMethod operation;
        
        __host__ __device__ T operator()(T xi1, T xi2) const {
            return  (this->*operation)(xi1,xi2);
        }"""]
    end #statFunc
end #kts

.template<typename T,int StateDim> struct BinaryOpF : public CuFunctor<T,StateDim> {
if(!kts)
    .    // this member will hold a pointer to the subclass's impl of the operator()(ulong) method
    bopm = bopMethodDec[0] + "StateDim" + bopMethodDec[1]
    .&{bopm}
    .
    .    __host__ __device__ void init(int currDev) {
    
    if(statFunc) 
    .        fn = 0;
    else
    .        operation = 0;
    end #statFunc
    
    .    }
    ./*
    . *     stateless binary ops
    . */
else
    .    __host__ __device__ T operator()(T xi1, T xi2) const { return 17; }
    .    __host__ __device__ void init(int currDev) {}
end #kts    
.};
.


if(!kts)
    # finder preamble
    ./!append(fMethodTableMgr)
    .
    ./*
    . * Store the device-side addresses of stateless bynary op functors
    . */
    if(statFunc) 
        .template <typename T> __global__ void findBop0sFunctions(
        .       typename BinaryOpF<T,0>::bopFunction *bopFunctions) {
    else
        .template <typename T> __global__ void findBop0sMethods(
        .       typename BinaryOpF<T,0>::bopMethod *bopMethods) {
    end #statFunc
    
    # create 0 template
    . /!append(fBaseBop)
    . // stateless
    .template<typename T> struct BinaryOpF<T,0>: public CuFunctor<T, 0> {
    .
    bopm = bopMethodDec[0] + "0" + bopMethodDec[1]
    .&{bopm}
    
    # add line break from 0s filler copies
    if(statFunc) 
        setup0sFunctionTables += "\n"
    else
        setup0sMethodTables += "\n"
    end #statFunc
end # kts

allBopAccs=""
allBopDecs=""
allBopImpls=""

nameExps = [
    ["Divisible", "return (xi1 / xi2) * xi2 == xi1 ? xi2 : 0;"],
    ["MisclassificationError", "return (xi1 >= .5 && xi2 == 0) || (xi1 < .5 && xi2 == 1) ? 1 : 0;"],
    ["DiffSquared", "return ((xi2 - xi1) * (xi2 - xi1));"],
    ["Equals", "return (xi1 == xi2);"],
    ["Quotient", "return (xi1 / xi2);"],
        ]
        
if(!kts)
    # create enum
    . /!append(fEnum)
    .enum BinaryOp0sMethods {
end

nameExps.each do |nameExp|
    name = nameExp[0]
    uncap = name.uncapitalize
    exp = nameExp[1]
    
    if(!kts)
        # write enum
        . /!append(fEnum)
        .    Bop0s@{name}BinaryOp,
        # write finder
        . /!append(fMethodTableMgr)
        
        if(statFunc)
        .    bopFunctions[Bop0s@{name}BinaryOp] = &BinaryOpF<T,0>::operator@{name};
        .    if(checkDebug(debugFtor))printf("found bopFunctions[Bop0s@{name}BinaryOp] %p\n", &BinaryOpF<T,0>::operator@{name});
        else
        .    bopMethods[Bop0s@{name}BinaryOp] = &BinaryOpF<T,0>::operator@{name};
        .    if(checkDebug(debugFtor))printf("found bopMethods[Bop0s@{name}BinaryOp] %p\n", &BinaryOpF<T,0>::operator@{name});
        end #statFunc
    
        ./!append(fBinaryOp)
        #add method copy
        if(statFunc)
            setup0sFunctionTables += "    checkCudaErrors(cudaMemcpy(&FunctionTableMgr<T>::h_bop0sFunctions[device][Bop0s" + name + "BinaryOp], &bopFunctions[Bop0s" + name + "BinaryOp], sizeof(typename BinaryOpF<T,0>::bopFunction),cudaMemcpyDeviceToHost));\n"
        else
            setup0sMethodTables += "    checkCudaErrors(cudaMemcpy(&MethodTableMgr<T>::h_bop0sMethods[device][Bop0s" + name + "BinaryOp], &bopMethods[Bop0s" + name + "BinaryOp], sizeof(typename BinaryOpF<T,0>::bopMethod),cudaMemcpyDeviceToHost));\n"
        end #statFunc
    end #kts
        
    if(locateFunction) 
        tempExp = exp 
        exp = "\nif(checkDebug(debugFtor))printf(\"invoked " + name + "'s operator()\\n\");\n" + exp
    end #locate
    
    .template<typename T> struct @{uncap}BinaryOp: public BinaryOpF<T,0> {
    .    __host__ __device__ T operator()(T xi1, T xi2) const {
    .        @{exp}
    .    }
    
    if(locateFunction) 
        exp = tempExp
        exp = "if(checkDebug(debugFtor))printf(\"invoked operator"+name+"()\\n\");\n    " + exp
    end #locate
    expStatic = exp
    
    if(!kts) 
        ./!append(fBaseBop)
        if(statFunc) 
        .    static __host__ __device__ T operator@{name}(const BinaryOpF<T,0>&,T,T);
            expStatic = expStatic.gsub(/(\w*_ro\(\))/, 'ref.\1')
            allBopImpls += "template <typename T> __host__ __device__ T BinaryOpF<T,0>::operator" + name+ "(const BinaryOpF<T,0>& ref, T xi1, T xi2){\n    " + expStatic +"\n}\n\n"
        else
        .    __host__ __device__ T operator@{name}(T,T) const;
            allBopImpls += "template <typename T>  __host__ __device__ T BinaryOpF<T,0>::operator" + name+ "(T xi1, T xi2) const {\n    " + exp +"\n}\n\n"
        end #statFunc
    end #kts    
    ./!append(fBinaryOp)
    .    __host__ __device__ void init(int currentDevice ) {
    if(!kts)
        if(statFunc) 
        .    #ifdef __CUDA_ARCH__
        .        ((BinaryOpF<T,0>*)this)->fn = &BinaryOpF<T,0>::operator@{name};
        .    #else
        .        BinaryOpF<T,0>::fn =  FunctionTableMgr<T>::h_bop0sFunctions[currentDevice][Bop0s@{name}BinaryOp];
        .    #endif
        else
        .    #ifdef __CUDA_ARCH__
        .        ((BinaryOpF<T,0>*)this)->operation = &BinaryOpF<T,0>::operator@{name};
        .    #else
        .        BinaryOpF<T,0>::operation =  MethodTableMgr<T>::h_bop0sMethods[currentDevice][Bop0s@{name}BinaryOp];
        .    #endif
        end #statFunc
    end #kts    
    .    }
    .}; // @{uncap}BinaryOp
    .
    # 
end # ---------------- do stateless binary ops ------------------------------
# 

if(!kts)
    # close unaryOp enum 
    . /!append(fEnum)
    .    Bop0sLast
    .}; // bop0s enum

    ./!append(fMethodTableMgr)
    .} // bop0s finder
end #kts



./!append(fBinaryOp)
./*
. *     monoids
. */
.template<typename T,int StateDim> struct MonoidF : public BinaryOpF<T,StateDim> {
if(!kts)
    .    using BinaryOpF<T,StateDim>::operator();
end
.    __host__ __device__ T& identity() { return CuFunctor<T,1>::state; }
.    __host__ __device__ const T& identity_ro() const { return CuFunctor<T,1>::state; }
.};
.

if(!kts)
    # finder preamble
    ./!append(fMethodTableMgr)
    .
    ./*
    . * Store the device-side addresses of binary op functors with 1d state (monoids have at least one state, for identity)
    . */
    if (statFunc) 
        .template <typename T> __global__ void findBop1sFunctions(
        .       typename BinaryOpF<T,1>::bopFunction *bopFunctions) {
    else
        .template <typename T> __global__ void findBop1sMethods(
        .       typename BinaryOpF<T,1>::bopMethod *bopMethods) {
    end #statFunc
    
    # create 1 template
    . /!append(fBaseBop)
    .};  // base bop1s template
    .
    . // 1d
    .template<typename T> struct BinaryOpF<T,1>: public CuFunctor<T, 1> {
    .
    bopm = bopMethodDec[0] + "1" + bopMethodDec[1]
    .&{bopm}
    .
end #kts

./!append(fBinaryOp)

# separate from iop1s copies
if(statFunc) 
    setup1sFunctionTables += "\n"; 
else
    setup1sMethodTables += "\n"; 
end #statFunc

nameExps = [
    ["Mult", "1",  "return (xi1 * xi2);"],
    ["SqrPlus", "0", "return (xi1 * xi1 + xi2 * xi2);"],
    ["Plus", "0", "return (xi1 + xi2);"],
    ["Minus", "0", "return (xi1 - xi2);"],
    ["Min",  "util<T>::maxValue()","return MIN(xi1, xi2);"],
    ["MinNotZero", "util<T>::maxValue()",
"""     if (xi1 == 0 && xi2 != 0)
            return xi2;
        if (xi1 != 0 && xi2 == 0)
            return xi1;
        return MIN(xi1, xi2);
"""],
    ["Max", "util<T>::minValue()",  "return MAX(xi1, xi2);"],
    ["And", "true", "return (xi1 && xi2);"],
    ["Or", "false",  "return (xi1 || xi2);"],
    ["Gt",  "0","return (xi1 > xi2);"],
    ["Lt",  "0","return (xi1 < xi2);"],
        ]
        
if(!kts) 
    # create enum
    . /!append(fEnum)
    .enum BinaryOp1sMethods {
end #kts

nameExps.each do |nameExp|
    name = nameExp[0]
    uncap = name.uncapitalize
    ident = nameExp[1]
    exp = nameExp[2]
    
    if(!kts)
        # write enum
        . /!append(fEnum)
        .    Bop1s@{name}BinaryOp,
        
        # write finder
        . /!append(fMethodTableMgr)
        
        if(statFunc)
        .    bopFunctions[Bop1s@{name}BinaryOp] = &BinaryOpF<T,1>::operator@{name};
        .    if(checkDebug(debugFtor))printf("found bopFunctions[Bop1s@{name}BinaryOp] %p\n", &BinaryOpF<T,1>::operator@{name});
        else
        .    bopMethods[Bop1s@{name}BinaryOp] = &BinaryOpF<T,1>::operator@{name};
        .    if(checkDebug(debugFtor))printf("found bopMethods[Bop1s@{name}BinaryOp] %p\n", &BinaryOpF<T,1>::operator@{name});
        end #statFunc
            
        #add method copy
        if(statFunc)
            setup1sFunctionTables += "    checkCudaErrors(cudaMemcpy(&FunctionTableMgr<T>::h_bop1sFunctions[device][Bop1s" + name + "BinaryOp], &bopFunctions[Bop1s" + name + "BinaryOp], sizeof(typename BinaryOpF<T,1>::bopFunction),cudaMemcpyDeviceToHost));\n"
        else
            setup1sMethodTables += "    checkCudaErrors(cudaMemcpy(&MethodTableMgr<T>::h_bop1sMethods[device][Bop1s" + name + "BinaryOp], &bopMethods[Bop1s" + name + "BinaryOp], sizeof(typename BinaryOpF<T,1>::bopMethod),cudaMemcpyDeviceToHost));\n"
        end #statFunc
    end #kts
        
    if(locateFunction) 
        tempExp = exp 
        exp = "\nif(checkDebug(debugFtor))printf(\"invoked " + name + "'s operator()\\n\");\n" + exp
    end #locate
    
    ./!append(fBinaryOp)
    .template<typename T>
    .struct @{uncap}BinaryOp: public MonoidF<T,1> {
    .    using MonoidF<T,1>::identity;
    .    using MonoidF<T,1>::identity_ro;
    .    __host__ __device__ T operator()(T xi1, T xi2) const {
    .        @{exp}
    .    }
    
    if(!kts)
        accessor="identity"
        ./!append(fBaseBop)
        if(!allBopAccs.include?(accessor+"_ro"))  
           allBopAccs[allBopAccs.length] = accessor+"_ro"
        .    __host__ __device__ T&  @{accessor}();
        .    __host__ __device__ const T&  @{accessor}_ro() const;
            allBopImpls += "template <typename T> __host__ __device__ T&  BinaryOpF<T,1>::"+accessor + "() { return CuFunctor<T,1>::state; };\n"
            allBopImpls += "template <typename T> __host__ __device__ const T& BinaryOpF<T,1>::"+accessor + "_ro() const { return CuFunctor<T,1>::state; };\n"
        end #!allBopAccs.include?(accessor
        
        if(locateFunction) 
            exp = tempExp
            exp = "if(checkDebug(debugFtor))printf(\"invoked operator"+name+"()\\n\");\n    " + exp
        end #locate 
        expStatic = exp
        
        if(statFunc) 
        .    static __host__ __device__ T operator@{name}(const BinaryOpF<T,1>&,T,T);
            expStatic = expStatic.gsub(/(\w*_ro\(\))/, 'ref.\1')
            allBopImpls += "template <typename T> __host__ __device__ T BinaryOpF<T,1>::operator" + name+ "(const BinaryOpF<T,1>& ref, T xi1, T xi2) {\n    " + expStatic +"\n}\n\n"
        else
        .    __host__ __device__ T operator@{name}(T,T) const;
            allBopImpls += "template <typename T>  __host__ __device__ T BinaryOpF<T,1>::operator" + name+ "(T xi1, T xi2) const {\n    " + exp +"\n}\n\n"
        end #statFunc
    end #kts    
    ./!append(fBinaryOp)
    .    __host__ __device__ void init(int currentDevice ) {
    if(!kts)
        if(statFunc) 
        .    #ifdef __CUDA_ARCH__
        .        ((BinaryOpF<T,1>*)this)->fn = &BinaryOpF<T,1>::operator@{name};
        .    #else
        .        ((BinaryOpF<T,1>*)this)->fn =  FunctionTableMgr<T>::h_bop1sFunctions[currentDevice][Bop1s@{name}BinaryOp];
        .    #endif
        else
        .    #ifdef __CUDA_ARCH__
        .        ((BinaryOpF<T,1>*)this)->operation = &BinaryOpF<T,1>::operator@{name};
        .    #else
        .        BinaryOpF<T,1>::operation =  MethodTableMgr<T>::h_bop1sMethods[currentDevice][Bop1s@{name}BinaryOp];
        .    #endif
        end #statFUnc
    end #kts
    .        identity() = @{ident};
    .    }
    .};  // @{uncap}BinaryOp
    .
    #
end # ------------------- do monoids ----------------------------------------
#


./*
. *     other 1d state binary ops
. */

nameExps = [
    ["AlmostEquals", "epsilon", "return (abs(xi2 - xi1) < epsilon);"], 
    
        ]

nameExps.each do |nameExp|
    name = nameExp[0]
    prop = nameExp[1]
    uncap = name.uncapitalize
    exp = nameExp[2]
    
    if(!kts)
        # write enum
        . /!append(fEnum)
        .    Bop1s@{name}BinaryOp,
        
        # write finder
        . /!append(fMethodTableMgr)
        if(statFunc) 
        .    bopFunctions[Bop1s@{name}BinaryOp] = &BinaryOpF<T,1>::operator@{name};
        .    if(checkDebug(debugFtor))printf("found bopFunctions[Bop1s@{name}BinaryOp] %p\n", &BinaryOpF<T,1>::operator@{name});
        else
        .    bopMethods[Bop1s@{name}BinaryOp] = &BinaryOpF<T,1>::operator@{name};
        .    if(checkDebug(debugFtor))printf("found bopMethods[Bop1s@{name}BinaryOp] %p\n", &BinaryOpF<T,1>::operator@{name});
        end #statFunc
        
        ./!append(fBinaryOp)
        #add method copy
        if(statFunc) 
            setup1sFunctionTables += "    checkCudaErrors(cudaMemcpy(&FunctionTableMgr<T>::h_bop1sFunctions[device][Bop1s" + name + "BinaryOp], &bopFunctions[Bop1s" + name + "BinaryOp], sizeof(typename BinaryOpF<T,1>::bopFunction),cudaMemcpyDeviceToHost));\n"
        else
            setup1sMethodTables += "    checkCudaErrors(cudaMemcpy(&MethodTableMgr<T>::h_bop1sMethods[device][Bop1s" + name + "BinaryOp], &bopMethods[Bop1s" + name + "BinaryOp], sizeof(typename BinaryOpF<T,1>::bopMethod),cudaMemcpyDeviceToHost));\n"
        end #statFunc
    end #kts    
    
    if(locateFunction) 
        tempExp = exp 
        exp = "\nif(checkDebug(debugFtor))printf(\"invoked " + name + "'s operator()\\n\");\n" + exp
    end #lcoate 
    exp = exp.gsub(prop, prop + "_ro()")
    
    .template<typename T> struct @{uncap}BinaryOp: public BinaryOpF<T,1> {
    .
    .    __host__ __device__ inline T&  @{prop}() { return CuFunctor<T,1>::state; }
    .    __host__ __device__ inline const T& @{prop}_ro() const { return CuFunctor<T,1>::state; }
    .
    .    __host__ __device__ T operator()(T xi1, T xi2) const {
    .        @{exp}
    .    }
    
    if(!kts) 
        ./!append(fBaseBop)
        if(!allBopAccs.include?(prop+"_ro"))  
           allBopAccs[allBopAccs.length] = prop+"_ro"
        .    __host__ __device__ T&  @{prop}();
        .    __host__ __device__ const T&  @{prop}_ro() const;
            allBopImpls += "template <typename T> __host__ __device__ T&  BinaryOpF<T,1>::"+prop + "() { return CuFunctor<T,1>::state; };\n"
            allBopImpls += "template <typename T> __host__ __device__ const T& BinaryOpF<T,1>::"+prop + "_ro() const { return CuFunctor<T,1>::state; };\n"
        end #!allBopAccs.include?(prop
        
        if(locateFunction) 
            exp = tempExp
            exp = "if(checkDebug(debugFtor))printf(\"invoked operator"+name+"()\\n\");\n    " + exp
        end #locate 
        expStatic = exp
        
        if(statFunc) 
        .    static __host__ __device__ T operator@{name}(const BinaryOpF<T,1>&,T,T);
            expStatic = expStatic.gsub(/(\w*_ro\(\))/, 'ref.\1')
            allBopImpls += "template <typename T> __host__ __device__ T BinaryOpF<T,1>::operator" + name+ "(const BinaryOpF<T,1>& ref, T xi1, T xi2){\n    " + expStatic +"\n}\n\n"
        else
        .    __host__ __device__ T operator@{name}(T,T) const;
            allBopImpls += "template <typename T>  __host__ __device__ T BinaryOpF<T,1>::operator" + name+ "(T xi1, T xi2) const {\n    " + exp +"\n}\n\n"
        end #statFunc
     end #kts
    ./!append(fBinaryOp)
    .    __host__ __device__ void init(int currentDevice, T _@{prop} = (T)0 ) {
    if(!kts)
        if(statFunc) 
        .    #ifdef __CUDA_ARCH__
        .        ((BinaryOpF<T,1>*)this)->fn = &BinaryOpF<T,1>::operator@{name};
        .    #else
        .        ((BinaryOpF<T,1>*)this)->fn =  FunctionTableMgr<T>::h_bop1sFunctions[currentDevice][Bop1s@{name}BinaryOp];
        .    #endif
        else
        .    #ifdef __CUDA_ARCH__
        .        ((BinaryOpF<T,1>*)this)->operation = &BinaryOpF<T,1>::operator@{name};
        .    #else
        .        ((BinaryOpF<T,1>*)this)->operation =  MethodTableMgr<T>::h_bop1sMethods[currentDevice][Bop1s@{name}BinaryOp];
        .    #endif
        end #statFunc
    end #kts    
    .        @{prop}() = _@{prop};
    .    }
    .}; //  @{uncap}BinaryOp
    .
    #
end # -------------- do other 1d binary ops -----------------------------
#

if(!kts) 
    . /!append(fBaseBop)
    .};  // base bop1s template
    .
    .&{allBopImpls}
    # close unaryOp enum 
    . /!append(fEnum)
    .    Bop1sLast
    .}; // bop1s enum
    
    ./!append(fMethodTableMgr)
    .} // bop1s finder
end #kts


if(!kts)
    #write 0s setup method
    .
    .
    ./*
    . * the MethodTableMgr<T>::setupXsMethodTables methods copy the __device__ method pointer arrays  (which point to
    . * each functor's operator() method) that were filled in the corresponding findXXXYsMethods kernels
    . */
    .
    if(statFunc)
    .template <typename T> void FunctionTableMgr<T>::setup0sFunctionTables(int device) {
    .    typename UnaryOpIndexF<T,0>::iopFunction * iopFunctions;
    .    typename UnaryOpF<T,0>::uopFunction * uopFunctions;
    .    typename BinaryOpF<T,0>::bopFunction * bopFunctions;
    .    checkCudaErrors(cudaMalloc(&iopFunctions, Iop0sLast * sizeof(typename UnaryOpIndexF<T,0>::iopFunction)));
    .    checkCudaErrors(cudaMalloc(&uopFunctions, Uop0sLast * sizeof(typename UnaryOpF<T,0>::uopFunction)));
    .    checkCudaErrors(cudaMalloc(&bopFunctions, Bop0sLast * sizeof(typename BinaryOpF<T,0>::bopFunction)));
    .    if(checkDebug(debugFtor))printf("void FunctionTableMgr<T>::setup0sFunctionTables() Iop0sLast %d iopFunctions @ %p\n", Iop0sLast, iopFunctions);
    .    if(checkDebug(debugFtor))printf("void FunctionTableMgr<T>::setup0sFunctionTables() Uop0sLast %d uopFunctions @ %p\n", Uop0sLast, uopFunctions);
    .    if(checkDebug(debugFtor))printf("void FunctionTableMgr<T>::setup0sFunctionTables() Bop0sLast %d bopFunctions @ %p\n", Bop0sLast, bopFunctions);
    .    findUop0sFunctions<T><<<1,1>>>(uopFunctions);
    .    checkCudaErrors(cudaDeviceSynchronize());
    .    findIop0sFunctions<T><<<1,1>>>(iopFunctions);
    .    checkCudaErrors(cudaDeviceSynchronize());
    .    findBop0sFunctions<T><<<1,1>>>(bopFunctions);
    .    checkCudaErrors(cudaDeviceSynchronize());
    .
    .&{setup0sFunctionTables}
    .    if(checkDebug(debugFtor))for(int i=0; i < Iop0sLast; i++) {
    .           printf("FunctionTableMgr<T>::setup0sFunctionTables h_iop0sFunctions %d at %p\n", i, FunctionTableMgr<T>::h_iop0sFunctions[device][i]);
    .    }   
    .
    .    // free temporary device-side method arrays
    .    checkCudaErrors(cudaFree(iopFunctions));
    .    checkCudaErrors(cudaFree(uopFunctions));
    .    checkCudaErrors(cudaFree(bopFunctions));
    .}
    else
    .template <typename T> void MethodTableMgr<T>::setup0sMethodTables(int device) {
    .    typename UnaryOpIndexF<T,0>::iopMethod * iopMethods;
    .    typename UnaryOpF<T,0>::uopMethod * uopMethods;
    .    typename BinaryOpF<T,0>::bopMethod * bopMethods;
    .    if(checkDebug(debugFtor))printf("MethodTableMgr<%s>::setup0sMethodTables(%d)\n", typeid(T).name(), device);
    .    checkCudaErrors(cudaMalloc(&iopMethods, Iop0sLast * sizeof(typename UnaryOpIndexF<T,0>::iopMethod)));
    .    checkCudaErrors(cudaMalloc(&uopMethods, Uop0sLast * sizeof(typename UnaryOpF<T,0>::uopMethod)));
    .    checkCudaErrors(cudaMalloc(&bopMethods, Bop0sLast * sizeof(typename BinaryOpF<T,0>::bopMethod)));
    .    if(checkDebug(debugFtor))printf("void MethodTableMgr<T>::setup0sMethodTables() Iop0sLast %d iopMethods @ %p\n", Iop0sLast, iopMethods);
    .    if(checkDebug(debugFtor))printf("void MethodTableMgr<T>::setup0sMethodTables() Uop0sLast %d uopMethods @ %p\n", Uop0sLast, uopMethods);
    .    if(checkDebug(debugFtor))printf("void MethodTableMgr<T>::setup0sMethodTables() Bop0sLast %d bopMethods @ %p\n", Bop0sLast, bopMethods);
    .    findUop0sMethods<T><<<1,1>>>(uopMethods);
    .    checkCudaErrors(cudaDeviceSynchronize());
    .    findIop0sMethods<T><<<1,1>>>(iopMethods);
    .    checkCudaErrors(cudaDeviceSynchronize());
    .    findBop0sMethods<T><<<1,1>>>(bopMethods);
    .    checkCudaErrors(cudaDeviceSynchronize());
    .
    .&{setup0sMethodTables}
    .    if(checkDebug(debugFtor))for(int i=0; i < Iop0sLast; i++) {
    .           printf("MethodTableMgr<T>::setup0sMethodTables h_iop0sMethods %d at %p\n", i, MethodTableMgr<T>::h_iop0sMethods[device][i]);
    .    }   
    .
    .    // free temporary device-side method arrays
    .    checkCudaErrors(cudaFree(iopMethods));
    .    checkCudaErrors(cudaFree(uopMethods));
    .    checkCudaErrors(cudaFree(bopMethods));
    .}
    
    end #statFunc
    
    #write 1s setup method
    .// 
    if(statFunc)
    .template <typename T> void FunctionTableMgr<T>::setup1sFunctionTables(int device) {
    .    typename UnaryOpIndexF<T,1>::iopFunction * iopFunctions;
    .    typename UnaryOpF<T,1>::uopFunction * uopFunctions;
    .    typename BinaryOpF<T,1>::bopFunction * bopFunctions;
    .    checkCudaErrors(cudaMalloc(&iopFunctions, Iop1sLast * sizeof(typename UnaryOpIndexF<T,1>::iopFunction)));
    .    checkCudaErrors(cudaMalloc(&uopFunctions, Uop1sLast * sizeof(typename UnaryOpF<T,1>::uopFunction)));
    .    checkCudaErrors(cudaMalloc(&bopFunctions, Bop1sLast * sizeof(typename BinaryOpF<T,1>::bopFunction)));
    .    findUop1sFunctions<T><<<1,1>>>(uopFunctions);
    .    findIop1sFunctions<T><<<1,1>>>(iopFunctions);
    .    findBop1sFunctions<T><<<1,1>>>(bopFunctions);
    .    checkCudaErrors(cudaDeviceSynchronize());
    .
    .&{setup1sFunctionTables}
    .    if(checkDebug(debugFtor))for(int i=0; i < Iop1sLast; i++) {
    .           printf("FunctionTableMgr<T>::setup1sFunctionTables h_iop1sFunctions %d at %p\n", i, FunctionTableMgr<T>::h_iop1sFunctions[device][i]);
    .    }   
    .
    .    checkCudaErrors(cudaFree(iopFunctions));
    .    checkCudaErrors(cudaFree(uopFunctions));
    .    checkCudaErrors(cudaFree(bopFunctions));
    .}
    else
    .template <typename T> void MethodTableMgr<T>::setup1sMethodTables(int device) {
    .    typename UnaryOpIndexF<T,1>::iopMethod * iopMethods;
    .    typename UnaryOpF<T,1>::uopMethod * uopMethods;
    .    typename BinaryOpF<T,1>::bopMethod * bopMethods;
    .    checkCudaErrors(cudaMalloc(&iopMethods, Iop1sLast * sizeof(typename UnaryOpIndexF<T,1>::iopMethod)));
    .    checkCudaErrors(cudaMalloc(&uopMethods, Uop1sLast * sizeof(typename UnaryOpF<T,1>::uopMethod)));
    .    checkCudaErrors(cudaMalloc(&bopMethods, Bop1sLast * sizeof(typename BinaryOpF<T,1>::bopMethod)));
    
    .    if(checkDebug(debugFtor))printf("void MethodTableMgr<T>::setup1sMethodTables() Iop1sLast %d iopMethods @ %p\n", Iop1sLast, iopMethods);
    .    if(checkDebug(debugFtor))printf("void MethodTableMgr<T>::setup1sMethodTables() Uop1sLast %d uopMethods @ %p\n", Uop1sLast, uopMethods);
    .    if(checkDebug(debugFtor))printf("void MethodTableMgr<T>::setup1sMethodTables() Bop1sLast %d bopMethods @ %p\n", Bop1sLast, bopMethods);
    
    .    findUop1sMethods<T><<<1,1>>>(uopMethods);
    .    findIop1sMethods<T><<<1,1>>>(iopMethods);
    .    findBop1sMethods<T><<<1,1>>>(bopMethods);
    .    checkCudaErrors(cudaDeviceSynchronize());
    .
    .&{setup1sMethodTables}
    .    if(checkDebug(debugFtor))for(int i=0; i < Iop1sLast; i++) {
    .           printf("MethodTableMgr<T>::setup1sMethodTables h_iop1sMethods %d at %p\n", i, MethodTableMgr<T>::h_iop1sMethods[device][i]);
    .    }   
    .
    .
    .    // free! free!
    .    checkCudaErrors(cudaFree(iopMethods));
    .    checkCudaErrors(cudaFree(uopMethods));
    .    checkCudaErrors(cudaFree(bopMethods));
    .}
    end #statFunc
    .
    #write 2s setup method
    . 
    if(statFunc)
    .template <typename T> void FunctionTableMgr<T>::setup2sFunctionTables(int device) {
    .    typename UnaryOpIndexF<T,2>::iopFunction * iopFunctions;
    .    typename UnaryOpF<T,2>::uopFunction * uopFunctions;
    .    checkCudaErrors(cudaMalloc(&iopFunctions, Iop2sLast * sizeof(typename UnaryOpIndexF<T,2>::iopFunction)));
    .    checkCudaErrors(cudaMalloc(&uopFunctions, Uop2sLast * sizeof(typename UnaryOpF<T,2>::uopFunction)));

    .    if(checkDebug(debugFtor))printf("void FunctionTableMgr<T>::setup2sFunctionTables() Iop2sLast %d iopFunctions @ %p\n", Iop2sLast, iopFunctions);
    .    if(checkDebug(debugFtor))printf("void FunctionTableMgr<T>::setup2sFunctionTables() Uop2sLast %d uopFunctions @ %p\n", Uop2sLast, uopFunctions);
    
    .    findUop2sFunctions<T><<<1,1>>>(uopFunctions);
    .    findIop2sFunctions<T><<<1,1>>>(iopFunctions);
    .    checkCudaErrors(cudaDeviceSynchronize());
    .
    .&{setup2sFunctionTables}
    .    if(checkDebug(debugFtor))for(int i=0; i < Iop2sLast; i++) {
    .           printf("FunctionTableMgr<T>::setup2sFunctionTables h_iop2sFunctions %d at %p\n", i, FunctionTableMgr<T>::h_iop2sFunctions[device][i]);
    .    }   
    .
    .    checkCudaErrors(cudaFree(iopFunctions));
    .    checkCudaErrors(cudaFree(uopFunctions));
    .}
    else
    .template <typename T> void MethodTableMgr<T>::setup2sMethodTables(int device) {
    .    typename UnaryOpIndexF<T,2>::iopMethod * iopMethods;
    .    typename UnaryOpF<T,2>::uopMethod * uopMethods;
    .    checkCudaErrors(cudaMalloc(&iopMethods, Iop2sLast * sizeof(typename UnaryOpIndexF<T,2>::iopMethod)));
    .    checkCudaErrors(cudaMalloc(&uopMethods, Uop2sLast * sizeof(typename UnaryOpF<T,2>::uopMethod)));
    .    if(checkDebug(debugFtor))printf("void MethodTableMgr<T>::setup2sMethodTables() device @ %d\n", device);
    .    findUop2sMethods<T><<<1,1>>>(uopMethods);
    .    findIop2sMethods<T><<<1,1>>>(iopMethods);
    .    checkCudaErrors(cudaDeviceSynchronize());
    .
    .&{setup2sMethodTables}
    .    if(checkDebug(debugFtor))for(int i=0; i < Iop2sLast; i++) {
    .           printf("MethodTableMgr<T>::setup2sMethodTables h_iop2sMethods %d at %p\n", i, MethodTableMgr<T>::h_iop2sMethods[device][i]);
    .    }   
    .
    .    // free! free!
    .    checkCudaErrors(cudaFree(iopMethods));
    .    checkCudaErrors(cudaFree(uopMethods));
    .}
    end #statFunc
    .
    #write 3s setup method
    .// 
    if(statFunc)
    .template <typename T> void FunctionTableMgr<T>::setup3sFunctionTables(int device) {
    .    typename UnaryOpIndexF<T,3>::iopFunction * iopFunctions;
    .    checkCudaErrors(cudaMalloc(&iopFunctions, Iop3sLast * sizeof(typename UnaryOpIndexF<T,3>::iopFunction)));
    .    if(checkDebug(debugFtor))printf("void FunctionTableMgr<T>::setup3sFunctionTables() Iop3sLast %d iopFunctions @ %p\n", Iop3sLast, iopFunctions);
    .    findIop3sFunctions<T><<<1,1>>>(iopFunctions);
    .    checkCudaErrors(cudaDeviceSynchronize());
    .    if(checkDebug(debugFtor))for(int i=0; i < Iop3sLast; i++) {
    .           printf("FunctionTableMgr<T>::setup3sFunctionTables h_iop3sFunctions %d at %p\n", i, FunctionTableMgr<T>::h_iop3sFunctions[device][i]);
    .    }   
    .&{setup3sFunctionTables}
    .
    .    // free! free!
    .    checkCudaErrors(cudaFree(iopFunctions));
    .};
    else
    .template <typename T> void MethodTableMgr<T>::setup3sMethodTables(int device) {
    .    typename UnaryOpIndexF<T,3>::iopMethod * iopMethods;
    .    checkCudaErrors(cudaMalloc(&iopMethods, Iop3sLast * sizeof(typename UnaryOpIndexF<T,3>::iopMethod)));
    .    if(checkDebug(debugFtor))printf("void MethodTableMgr<T>::setup3sMethodTables() device @ %d\n", device);
    .    findIop3sMethods<T><<<1,1>>>(iopMethods);
    .    checkCudaErrors(cudaDeviceSynchronize());
    .    if(checkDebug(debugFtor))for(int i=0; i < Iop3sLast; i++) {
    .           printf("MethodTableMgr<T>::setup3sMethodTables h_iop3sMethods %d at %p\n", i, MethodTableMgr<T>::h_iop3sMethods[device][i]);
    .    }   
    .&{setup3sMethodTables}
    .
    .    // free! free!
    .    checkCudaErrors(cudaFree(iopMethods));
    .};
    end #statFunc
    .
    if statFunc 
        .template<typename T> void unaryOpIndexMbrs<T>::setupAllFunctionTables(int device ) {
        .
        .    bool& configd = SetupMbrFuncs[getTypeEnum<T>()][device];
        .    if(!configd) {
        .    
        .        if(checkDebug(debugFtor))printf("building method tables for type %s and device %d\n",getTypeName<T>(), device);
        .        int currDev = ExecCaps::currDev();
        .        if(currDev != device) {
        .            if(checkDebug(debugFtor))printf("not current device, switching from %d to %d\n", currDev, device);
        .            checkCudaErrors(cudaSetDevice(device));
        .        }      
        .        FunctionTableMgr<T>::setup0sFunctionTables(device);
        .        FunctionTableMgr<T>::setup1sFunctionTables(device);
        .        FunctionTableMgr<T>::setup2sFunctionTables(device);
        .        FunctionTableMgr<T>::setup3sFunctionTables(device);
        .        if(checkDebug(debugFtor))printf("setting SetupMbrFuncs[%d][%d] to true\n", getTypeEnum<T>(),device);
        .        if(currDev != device) {
        .            if(checkDebug(debugFtor))printf("reverting current device to %d from %d\n", currDev, device);
        .            checkCudaErrors(cudaSetDevice(currDev));
        .        }      
        .    
        .        SetupMbrFuncs[getTypeEnum<T>()][device] = true;
        .    } else {
        .    }
        .}
        .template void unaryOpIndexMbrs<float>::setupAllFunctionTables(int);
        .template void unaryOpIndexMbrs<double>::setupAllFunctionTables(int);
        .template void unaryOpIndexMbrs<long>::setupAllFunctionTables(int);
        .template void unaryOpIndexMbrs<ulong>::setupAllFunctionTables(int);
        .template void unaryOpIndexMbrs<int>::setupAllFunctionTables(int);
        .template void unaryOpIndexMbrs<uint>::setupAllFunctionTables(int);
    else
        .template<typename T> void unaryOpIndexMbrs<T>::setupAllMethodTables(int device ) {
        .
        .    bool& configd = SetupMbrFuncs[getTypeEnum<T>()][device];
        .    if(!configd) {
        .    
        .        if(checkDebug(debugFtor))printf("building method tables for device %d\n",device);
        .        // caroooseeahl
        .        int currDev = ExecCaps::currDev();
        .        if(currDev != device) {
        .            if(checkDebug(debugFtor))printf("not current device, switching from %d to %d\n", currDev, device);
        .            checkCudaErrors(cudaSetDevice(device));
        .        }      
        .        MethodTableMgr<T>::setup0sMethodTables(device);
        .        MethodTableMgr<T>::setup1sMethodTables(device);
        .        MethodTableMgr<T>::setup2sMethodTables(device);
        .        MethodTableMgr<T>::setup3sMethodTables(device);
        .        if(checkDebug(debugFtor))printf("setting SetupMbrFuncs[%d][%d] to true\n", getTypeEnum<T>(),device);
        .        if(currDev != device) {
        .            if(checkDebug(debugFtor))printf("reverting current device to %d from %d\n", currDev, device);
        .            checkCudaErrors(cudaSetDevice(currDev));
        .        }      
        .    
        .        SetupMbrFuncs[getTypeEnum<T>()][device] = true;
        .    } else {
        .    }
        .}
        .template void unaryOpIndexMbrs<float>::setupAllMethodTables(int);
        .template void unaryOpIndexMbrs<double>::setupAllMethodTables(int);
        .template void unaryOpIndexMbrs<long>::setupAllMethodTables(int);
        .template void unaryOpIndexMbrs<ulong>::setupAllMethodTables(int);
        .template void unaryOpIndexMbrs<int>::setupAllMethodTables(int);
        .template void unaryOpIndexMbrs<uint>::setupAllMethodTables(int);
    end #statFunc
end #kts

./!append(fBinaryOp)
./!stdout()
